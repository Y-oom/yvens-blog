<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="shortcut icon" href="/favicon.ico"> <title>[Java] java.lang.OutOfMemoryError - Out of Memory</title> <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet"> <link rel="stylesheet" href="/assets/dist/css/style.css"> <!-- <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_big-stone.min.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_white.min.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-base16.dark.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-github.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> --> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>[Java] java.lang.OutOfMemoryError | Out of Memory</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="[Java] java.lang.OutOfMemoryError" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="INDEX" /> <meta property="og:description" content="INDEX" /> <link rel="canonical" href="https://outofmemory.blog/outofmemoryerror-p3.html" /> <meta property="og:url" content="https://outofmemory.blog/outofmemoryerror-p3.html" /> <meta property="og:site_name" content="Out of Memory" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2018-03-08T00:00:00+08:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="[Java] java.lang.OutOfMemoryError" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2018-03-08T00:00:00+08:00","datePublished":"2018-03-08T00:00:00+08:00","description":"INDEX","headline":"[Java] java.lang.OutOfMemoryError","mainEntityOfPage":{"@type":"WebPage","@id":"https://outofmemory.blog/outofmemoryerror-p3.html"},"url":"https://outofmemory.blog/outofmemoryerror-p3.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="content"> <header> <div class="main"> <a href="https://outofmemory.blog/">Out of Memory</a> </div> <nav> <a class='' href="/">首页</a> <!-- <a class='' href="/archives.html"> Archives</a> --> <a class='' href="/about.html">关于</a> </nav> </header> <hr class="light-hr"> <main> <div class="title"> <h1 class="title">[Java] java.lang.OutOfMemoryError</h1> <div class="meta"> <time datetime="08-03-2018">Mar 08 2018</time> </div> </div> <hr class="no-margin light-hr "> <blockquote> <p><a href="/outofmemoryerror">INDEX</a></p> </blockquote> <h2 id="javalangoutofmemoryerror-permgen-space">java.lang.OutOfMemoryError: Permgen space</h2> <p>Java applications are only allowed to use a limited amount of memory. The exact amount of memory your particular application can use is specified during application startup. To make things more complex, Java memory is separated into different regions which can be seen in the following figure:</p> <center> <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/assets/dist/images/2ad57p1mf.pic.png" /> <br /> </center> <p>The size of all those regions, including the permgen area, is set during the JVM launch. If you do not set the sizes yourself, platform-specific defaults will be used.</p> <p>The <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: PermGen space</code> message indicates that the Permanent Generation’s area in memory is exhausted.</p> <h3 id="what-is-causing-it">What is causing it?</h3> <p>To understand the cause for the <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: PermGen space</code>, we would need to understand what this specific memory area is used for.</p> <p>For practical purposes, the permanent generation consists mostly of class declarations loaded and stored into PermGen. This includes the name and fields of the class, methods with the method bytecode, constant pool information, object arrays and type arrays associated with a class and Just In Time compiler optimizations.</p> <p>From the above definition you can deduce that the PermGen size requirements depend both on the number of classes loaded as well as the size of such class declarations. Therefore we can say that the main cause for the <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: PermGen space</code> is that either too many classes or too big classes are loaded to the permanent generation.</p> <h3 id="give-me-an-example">Give me an example</h3> <h4 id="minimalistic-example">Minimalistic example</h4> <p>As we described above, <code class="language-plaintext highlighter-rouge">PermGen space</code> usage is strongly correlated with the number of classes loaded into the JVM. The following code serves as the most straightforward example:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">javassist.ClassPool</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MicroGenerator</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100_000_000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="n">generate</span><span class="o">(</span><span class="s">"eu.plumbr.demo.Generated"</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Class</span> <span class="nf">generate</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">ClassPool</span> <span class="n">pool</span> <span class="o">=</span> <span class="nc">ClassPool</span><span class="o">.</span><span class="na">getDefault</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">pool</span><span class="o">.</span><span class="na">makeClass</span><span class="o">(</span><span class="n">name</span><span class="o">).</span><span class="na">toClass</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>In this example the source code iterates over a loop and generates classes at runtime. Class generation complexity is being taken care of by the <a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/" target="_blank">javassist</a> library.</p> <p>Launching the code above will keep generating new classes and loading their definitions into <code class="language-plaintext highlighter-rouge">Permgen space</code> until the space is fully utilized and the <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: Permgen space</code> is thrown.</p> <h4 id="redeploy-time-example">Redeploy-time example</h4> <p>For a bit more complex and more realistic example, lets walk you through a <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: Permgen space</code> error occurring during the application redeploy. When you redeploy an application, you would expect that Garbage Collection will get rid of the previous classloader referencing all the previously loaded classes and it gets replaced with a classloader loading new versions of the classes.</p> <p>Unfortunately many 3rd party libraries and poor handling of resources such as threads, JDBC drivers or filesystem handles makes unloading the previously used classloader impossible. This in turn means that during each redeploy all the previous versions of your classes will still reside in PermGen generating tens of megabytes of garbage during each redeploy.</p> <p>Let’s imagine an example application that connects to a relational database using JDBC drivers. When the application is started, the initializing code loads the JDBC driver to connect to the database. Corresponding to the specification, the JDBC driver registers itself with <code class="language-plaintext highlighter-rouge">java.sql.DriverManager</code>. This registration includes storing a reference to an instance of the driver inside a static field of DriverManager.</p> <p>Now, when the application is undeployed from the application server, <code class="language-plaintext highlighter-rouge">java.sql.DriverManager</code> will still hold that reference. We end up having a live reference to the driver class which in turn holds reference to the instance of <code class="language-plaintext highlighter-rouge">java.lang.Classloader</code> used to load the application. This in turn means that the Garbage Collection Algorithms are not able to reclaim the space.</p> <p>And that instance of <code class="language-plaintext highlighter-rouge">java.lang.ClassLoader</code> still references all classes of the application, usually occupying tens of megabytes in PermGen. Which means that it would take just a handful of redeploys to fill a typically sized PermGen and get the <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: PermGen space</code> error message in your logs.</p> <h3 id="what-is-the-solution">What is the solution?</h3> <h4 id="1-solving-initialization-time-outofmemoryerror">1. Solving initialization-time OutOfMemoryError</h4> <p>When the OutOfMemoryError due to PermGen exhaustion is triggered during the application launch, the solution is simple. The application just needs more room to load all the classes to the PermGen area so we just need to increase its size. To do so, alter your application launch configuration and add (or increase if present) the <code class="language-plaintext highlighter-rouge">-XX:MaxPermSize</code> parameter similar to the following example:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">-XX</span>:MaxPermSize<span class="o">=</span>512m com.yourcompany.YourClass
</code></pre></div></div> <p>The above configuration will tell the JVM that PermGen is allowed to grow up to 512MB before it can start complaining in the form of OutOfMemoryError.</p> <h4 id="2-solving-redeploy-time-outofmemoryerror">2. Solving redeploy-time OutOfMemoryError</h4> <p>For those who cannot use Plumbr or decide not to, alternatives are also available. For this, you should proceed with heap dump analysis take the heap dump after a redeploy with a command similar to this one:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jmap <span class="nt">-dump</span>:format<span class="o">=</span>b,file<span class="o">=</span>dump.hprof &lt;process-id&gt;
</code></pre></div></div> <p>Then open the dump with your favourite heap dump analyzer (Eclipse MAT is a good tool for that). In the analyzer, you can look for duplicate classes, especially those loading your application classes. From there, you need to progress to all classloaders to find the currently active classloader.</p> <p>For the inactive classloaders, you need to determine the reference blocking them from being Garbage Collected via harvesting the shortest path to GC root from the inactive classloaders. Equipped with this information you will have found the root cause. In case the root cause was in a 3rd party library, you can proceed to <a href="javascript:;">Google</a>/<a href="javascript:;">StackOverflow</a> to see if this is a known issue to get a <code class="language-plaintext highlighter-rouge">patch/workaround</code>. If this was your own code, you need to get rid of the offending reference.</p> <h4 id="3-solving-run-time-outofmemoryerror">3. Solving run-time OutOfMemoryError</h4> <p>An alternative way for those once again who cannot use Plumbr is also available. First step in such case is to check whether the GC is allowed to unload classes from PermGen. The standard JVM is rather conservative in this regard classes are born to live forever. So once loaded, classes stay in memory even if no code is using them anymore. This can become a problem when the application creates lots of classes dynamically and the generated classes are not needed for longer periods. In such a case, allowing the JVM to unload class definitions can be helpful. This can be achieved by adding just one configuration parameter to your startup scripts:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-XX</span>:+CMSClassUnloadingEnabled
</code></pre></div></div> <p>By default this is set to false and so to enable this you need to explicitly set the following option in Java options. If you enable CMSClassUnloadingEnabled, GC will sweep PermGen too and remove classes which are no longer used. Keep in mind that this option will work only when UseConcMarkSweepGC is also enabled using the below option. So when running ParallelGC or, God forbid, Serial GC, make sure you have set your GC to CMS by specifying:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-XX</span>:+UseConcMarkSweepGC
</code></pre></div></div> <p>After making sure classes can be unloaded and the issue still persists, you should proceed with heap dump analysis taking the heap dump with a command similar to following:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jmap <span class="nt">-dump</span>:file<span class="o">=</span>dump.hprof,format<span class="o">=</span>b &lt;process-id&gt; 
</code></pre></div></div> <p>Then opening the dump with your favorite heap dump analyzer (e.g. Eclipse MAT) and progressing to find the most expensive classloaders by the number of classes loaded. From such classloaders, you can proceed to extract the loaded classes and sort such classes by the instances to have the top list of suspects.</p> <p>For each suspect, you then need to manually trace the root cause back to your application code that generates such classes.</p> <div class="post-tags"> <nav class="nav-post-tags-list"> <ul class="tags"> <li><a href="/tag/java/">Java</a></li> <li><a href="/tag/oom/">OOM</a></li> <li><a href="/tag/jvm/">JVM</a></li> </ul> </nav> </div> </main> <footer> <hr class="footer-hr"> <div class="ui-flex"> <div class='wrapper-footer'> © 2025 Out of Memory.blog | <a href="mailto:yvens.fv@gmail.com">yvens</a> </div> </div> </footer> </div> </body> </html>
