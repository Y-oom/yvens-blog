<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="shortcut icon" href="/favicon.ico"> <title>一文讲清多线程和多线程同步 - Out of Memory</title> <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet"> <link rel="stylesheet" href="/assets/dist/css/style.css"> <!-- <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_big-stone.min.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_white.min.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-base16.dark.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-github.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> --> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>一文讲清多线程和多线程同步 | Out of Memory</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="一文讲清多线程和多线程同步" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="本文转载自美团技术团队，原文链接" /> <meta property="og:description" content="本文转载自美团技术团队，原文链接" /> <link rel="canonical" href="https://outofmemory.blog/multi-threading-and-multi-thread-synchronization.html" /> <meta property="og:url" content="https://outofmemory.blog/multi-threading-and-multi-thread-synchronization.html" /> <meta property="og:site_name" content="Out of Memory" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2024-07-25T00:00:00+08:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="一文讲清多线程和多线程同步" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-07-25T00:00:00+08:00","datePublished":"2024-07-25T00:00:00+08:00","description":"本文转载自美团技术团队，原文链接","headline":"一文讲清多线程和多线程同步","mainEntityOfPage":{"@type":"WebPage","@id":"https://outofmemory.blog/multi-threading-and-multi-thread-synchronization.html"},"url":"https://outofmemory.blog/multi-threading-and-multi-thread-synchronization.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="content"> <header> <div class="main"> <a href="https://outofmemory.blog/">Out of Memory</a> </div> <nav> <a class='' href="/">首页</a> <!-- <a class='' href="/archives.html"> Archives</a> --> <a class='' href="/about.html">关于</a> </nav> </header> <hr class="light-hr"> <main> <div class="title"> <h1 class="title">一文讲清多线程和多线程同步</h1> <div class="meta"> <time datetime="25-07-2024">Jul 25 2024</time> </div> </div> <hr class="no-margin light-hr "> <blockquote> <p>本文转载自美团技术团队，<a href="https://tech.meituan.com/2024/07/19/multi-threading-and-multi-thread-synchronization.html" target="_blank">原文链接</a></p> </blockquote> <blockquote> <p>多线程编程是现代软件开发中的一项关键技术，在多线程编程中，开发者可以将复杂的任务分解为多个独立的线程，使其并行执行，从而充分利用多核处理器的优势。然而，多线程编程也带来了挑战，例如线程同步、死锁和竞态条件等问题。本篇文章将深入探讨多线程编程的基本概念（原子操作、CAS、Lock-free、内存屏障、伪共享、乱序执行等）、常见模式和最佳实践。通过具体的代码示例，希望能够帮助大家掌握多线程编程的核心技术，并在实际开发中应用这些知识，提升软件的性能和稳定性。</p> </blockquote> <h2 id="多线程">多线程</h2> <h3 id="1-线程的概念">1 线程的概念</h3> <p>十多年前，主流观点主张在可能的情况下优先选择多进程而非多线程。如今，多线程编程已经成为编程领域的事实标准。多线程技术在很大程度上改善了程序的性能和响应能力，使其能够更加高效地利用系统资源，这不仅归功于多核处理器的普及和软硬件技术的进步，还归功于开发者对多线程编程的深入理解和技术创新。</p> <p>那么什么是线程呢？线程是一个执行上下文，它包含诸多状态数据：每个线程有自己的执行流、调用栈、错误码、信号掩码、私有数据。Linux 内核用任务（Task）表示一个执行流。</p> <h4 id="11-执行流">1.1 执行流</h4> <p>一个任务里被依次执行的指令会形成一个指令序列（IP寄存器值的历史记录），这个指令序列就是一个指令流，每个线程会有自己的执行流。考虑下面的代码（本文代码块为C++）：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">char</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span>
      <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'-'</span><span class="p">)</span>
      <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'*'</span><span class="p">)</span>
      <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'/'</span><span class="p">)</span>
      <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"invalid operation</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">calc</code> 函数被编译成汇编指令，一行C代码对应一个或多个汇编指令，在一个线程里执行 <code class="language-plaintext highlighter-rouge">calc</code>，那么这些机器指令会被依次执行。但是，被执行的指令序列跟代码顺序可能不完全一致，代码中的分支、跳转等语句，以及编译器对指令重排、处理器乱序执行会影响指令的真正执行顺序。</p> <h4 id="12-逻辑线程-vs-硬件线程">1.2 逻辑线程 vs 硬件线程</h4> <p>线程可以进一步区分为逻辑线程和硬件线程。</p> <p><strong>逻辑线程</strong></p> <p>程序上的线程是一个逻辑上的概念，也叫任务、软线程、逻辑线程。线程的执行逻辑由代码描述，比如编写一个函数实现对一个整型数组的元素求和：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
          <span class="n">x</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div> <p>这个函数的逻辑很简单，它没有再调用其他函数（更复杂的功能逻辑可以在函数里调用其他函数）。我们可以在一个线程里调用这个函数对某数组求和；也可以把 <code class="language-plaintext highlighter-rouge">sum</code> 设置为某线程的入口函数，每个线程都会有一个入口函数，线程从入口函数开始执行。<code class="language-plaintext highlighter-rouge">sum</code> 函数描述了逻辑，即要做什么以及怎么做，偏设计；但它没有描述物质，即没有描述这个事情由谁做，事情最终需要派发到实体去完成。</p> <p><strong>硬件线程</strong></p> <p>与逻辑线程对应的是硬件线程，这是逻辑线程被执行的物质基础。</p> <p>芯片设计领域，一个硬件线程通常指为执行指令序列而配套的硬件单元，一个 CPU 可能有多个核心，然后核心还可能支持超线程，1个核心的2个超线程复用一些硬件。从软件的视角来看，无须区分是真正的 Core 和超出来的 VCore，基本上可以认为是2个独立的执行单元，每个执行单元是一个逻辑 CPU，从软件的视角看 CPU 只需关注逻辑 CPU。一个软件线程由哪个 CPU/Core 去执行，以及何时执行，不归应用程序员管，它由操作系统决定，操作系统中的调度系统负责此项工作。</p> <h3 id="2-线程核心函数的关系">2 线程、核心、函数的关系</h3> <p>线程入口函数是线程执行的起点，线程从入口函数开始、一个指令接着一个指令执行，中间它可能会调用其他函数，那么它的控制流就转到了被调用的函数继续执行，被调用函数里还可以继续调用其他函数，这样便形成一个函数调用链。</p> <p>前面的数组求和例子，如果数组特别大，则哪怕是一个简单的循环累加也可能耗费很长的时间，可以把这个整型数组分成多个小数组，或者表示成二维数组（数组的数组），每个线程负责一个小数组的求和，多个线程并发执行，最后再累加结果。</p> <p>所以，为了提升处理速度，可以让多个线程在不同数据区段上执行相同（或相似）的计算逻辑，同样的处理逻辑可以有多个执行实例（线程），这对应对数据拆分线程。当然，也可以为两个线程指定不同的入口函数，让各线程执行不同的计算逻辑，这对应对逻辑拆分线程。</p> <p>我们用一个例子来阐述线程、核心和函数之间的关系，假设有遛狗、扫地两类工作要做：</p> <ul> <li>遛狗就是为狗系上绳子然后牵着它在小区里溜达一圈，这句话就描述了遛狗的逻辑，即对应到函数定义，它是一个对应到设计的静态的概念。</li> <li>每项工作，最终需要人去做，人就对应到硬件：CPU/Core/VCore，是任务被完成的物质基础。</li> </ul> <p>那什么对应软件线程？ 任务拆分。</p> <p><strong>一个例子</strong></p> <p>假设现在有2条狗需要遛、3个房间需要打扫。可以把遛狗拆成2个任务，一个任务是遛小狗，另一个任务是遛大狗；打扫房间拆分为3个任务，3个房间对应3个任务，执行这样的拆分策略后，将会产生 2+3=5 个任务。但如果只有2个人，2个人无法同时做5件事，让某人在某时干某事由调度系统负责。</p> <p>如果张三在遛小狗，那就对应一个线程被执行，李四在扫房间A，则表示另一个线程在执行中，可见线程是一个动态的概念。</p> <p>软件线程不会一直处于执行中，原因是多方面的。上述例子是因为人手不够，所以遛大狗的任务还处于等待被执行的状态，其他的原因包括中断、抢占、条件依赖等。比如李四扫地过程中接到一个电话，他需要去处理更紧急的事情（接电话），则扫地这个事情被挂起，李四打完电话后继续扫地，则这个线程会被继续执行。</p> <p>如果只有1个人，则上述5个任务依然可以被依次或交错完成，所以多线程是一个编程模型，多线程并不一定需要多 CPU 多 Core，单 CPU 单 Core 系统依然可以运行多线程程序（虽然最大化利用多 CPU 多 Core 的处理能力是多线程程序设计的一个重要目标）。1个人无法同时做多件事，单 CPU/单 Core 也不可以，操作系统通过时间分片技术应对远多于 CPU/Core 数的多任务执行的挑战。也可以把有些任务只分配给某些人去完成，这对应到 CPU 亲和性和绑核。</p> <h3 id="3-程序进程线程协程">3 程序、进程、线程、协程</h3> <p>进程和线程是操作系统领域的两个重要概念，两者既有区别又有联系。</p> <h4 id="31-可执行程序">3.1 可执行程序</h4> <p>C/C++ 源文件经过编译器（编译+链接）处理后，会产生可执行程序文件，不同系统有不同格式，比如 Linux 系统的 ELF 格式、Windows 系统的 EXE 格式，可执行程序文件是一个静态的概念。</p> <h4 id="32-进程是什么">3.2 进程是什么</h4> <p>可执行程序在操作系统上的一次执行对应一个进程，进程是一个动态的概念：进程是执行中的程序。同一份可执行文件执行多次，会产生多个进程，这跟一个类可以创建多个实例一样。进程是资源分配的基本单位。</p> <h4 id="33-线程是什么">3.3 线程是什么</h4> <p>一个进程内的多个线程代表着多个执行流，这些线程以并发模式独立执行。操作系统中，被调度执行的最小单位是线程而非进程。进程是通过共享存储空间对用户呈现的逻辑概念，同一进程内的多个线程共享地址空间和文件描述符，共享地址空间意味着进程的代码（函数）区域、全局变量、堆、栈都被进程内的多线程共享。</p> <h4 id="34-进程和线程的关系">3.4 进程和线程的关系</h4> <p>先看看 Linus 的论述，在1996年的一封邮件里，Linus 详细阐述了他对进程和线程关系的深刻洞见，他在邮件里写道：</p> <ul> <li>把进程和线程区分为不同的实体是背着历史包袱的传统做法，没有必要做这样的区分，甚至这样的思考方式是一个主要错误。</li> <li>进程和线程都是一回事：一个执行上下文（context of execution），简称为 COE，其状态包括：<br /> ** CPU 状态（寄存器等）<br /> ** MMU 状态（页映射）<br /> ** 权限状态（uid、gid等）<br /> ** 各种通信状态（打开的文件、信号处理器等）</li> <li>传统观念认为：进程和线程的主要区别是线程有 CPU 状态（可能还包括其他最小必要状态），而其他上下文来自进程；然而，这种区分法并不正确，这是一种愚蠢的自我设限。</li> <li>Linux 内核认为根本没有所谓的进程和线程的概念，只有 COE（Linux称之为任务），不同的 COE 可以相互共享一些状态，通过此类共享向上构建起进程和线程的概念。</li> <li>从实现来看，Linux 下的线程目前是LWP实现，线程就是轻量级进程，所有的线程都当作进程来实现，因此线程和进程都是用 <code class="language-plaintext highlighter-rouge">task_struct</code> 来描述的。这一点通过 <code class="language-plaintext highlighter-rouge">/proc</code> 文件系统也能看出端倪，线程和进程拥有比较平等的地位。对于多线程来说，原本的进程称为主线程，它们在一起组成一个线程组。</li> </ul> <p>简言之，内核不要基于进程/线程的概念做设计，而应该围绕 COE 的思考方式去做设计，然后，通过暴露有限的接口给用户去满足 <code class="language-plaintext highlighter-rouge">pthreads</code> 库的要求。</p> <h4 id="35-协程">3.5 协程</h4> <p>用户态的多执行流，上下文切换成本比线程更低，微信用协程改造后台系统后，获得了更大吞吐能力和更高稳定性。如今，协程库也进了 C++ 20 新标准。</p> <h3 id="4-为什么需要多线程">4 为什么需要多线程</h3> <h4 id="41-什么是多线程">4.1 什么是多线程</h4> <p>一个进程内多个线程并发执行的情况就叫多线程，每个线程是一个独立的执行流，多线程是一种编程模型，它与处理器无关、跟设计有关。</p> <p>需要多线程的原因包括：</p> <ul> <li>并行计算：充分利用多核，提升整体吞吐，加快执行速度。</li> <li>后台任务处理：将后台线程和主线程分离，在特定场景它是不可或缺的，如：响应式用户界面、实时系统等。</li> </ul> <p>我们用2个例子作说明。</p> <h4 id="42-通过多线程并发提升处理能力">4.2 通过多线程并发提升处理能力</h4> <p>假设你要编写一个程序，用于统计一批文本文件的单词出现次数，程序的输入是文件名列表，输出一个单词到次数的映射。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 类型别名：单词到次数的映射</span>
  <span class="k">using</span> <span class="n">word2count</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="c1">// 合并“单词到次数映射列表”</span>
  <span class="n">word2count</span> <span class="nf">merge</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">word2count</span><span class="o">&gt;&amp;</span> <span class="n">w2c_list</span><span class="p">)</span> <span class="p">{</span><span class="cm">/*todo*/</span><span class="p">}</span>

  <span class="c1">// 统计一个文件里单词出现次数（单词到次数的映射）</span>
  <span class="n">word2count</span> <span class="n">word_count_a_file</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">file</span><span class="p">)</span> <span class="p">{</span><span class="cm">/*todo*/</span><span class="p">}</span>

  <span class="c1">// 统计一批文本文件的单词出现次数</span>
  <span class="n">word2count</span> <span class="n">word_count_files</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">files</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">word2count</span><span class="o">&gt;</span> <span class="n">w2c_list</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">file</span> <span class="o">:</span> <span class="n">files</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">w2c_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">word_count_a_file</span><span class="p">(</span><span class="n">file</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">w2c_list</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">files</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">files</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="p">}</span>
      <span class="k">auto</span> <span class="n">w2c</span> <span class="o">=</span> <span class="n">word_count_files</span><span class="p">(</span><span class="n">files</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div> <p>这是一个单线程程序，<code class="language-plaintext highlighter-rouge">word_count_files</code> 函数在主线程里被 <code class="language-plaintext highlighter-rouge">main</code> 函数调用。如果文件不多、又或者文件不大，那么运行这个程序，很快就会得到统计结果，否则，可能要等一段长的时间才能返回结果。</p> <p>重新审视这个程序会发现：函数 <code class="language-plaintext highlighter-rouge">word_count_a_file</code> 接受一个文件名，吐出从该文件计算出的局部结果，它不依赖于其他外部数据和逻辑，可以并发执行，所以，可以为每个文件启动一个单独的线程去运行 <code class="language-plaintext highlighter-rouge">word_count_a_file</code>，等到所有线程都执行完，再合并得到最终结果。</p> <p>实际上，为每个文件启动一个线程未必合适，因为如果有数万个小文件，那么启动数万个线程，每个线程运行很短暂的时间，大量时间将耗费在线程创建和销毁上，一个改进的设计：</p> <ul> <li>开启一个线程池，线程数等于 Core 数或二倍 Core 数（策略）。</li> <li>每个工作线程尝试去文件列表（文件列表需要用锁保护起来）里取一个文件。<br /> ** 成功，统计这个文件的单词出现次数。<br /> ** 失败，该工作线程就退出。</li> <li>待所有工作线程退出后，在主线程里合并结果。</li> </ul> <p>这样的多线程程序能加快处理速度，前面数组求和可以采用相似的处理，如果程序运行在多 CPU 多 Core 的机器上，就能充分利用多 CPU 多 Core 硬件优势，多线程加速执行是多线程的一个显而易见的主要目的，此其一。</p> <h4 id="43-通过多线程改变程序编写方式">4.3 通过多线程改变程序编写方式</h4> <p>其二，有些场景会有阻塞的调用，如果不用多线程，那么代码不好编写。</p> <p>比如某程序在执行密集计算的同时，需要监控标准输入（键盘），如果键盘有输入，那么读取输入并解析执行，但如果获取键盘输入的调用是阻塞的，而此时键盘没有输入到来，那么其他逻辑将得不到机会执行。</p> <p>代码看起来会像下面这样子：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 从键盘接收输入，经解释后，会构建一个Command对象返回</span>
  <span class="n">Command</span> <span class="n">command</span> <span class="o">=</span> <span class="n">getCommandFromStdInput</span><span class="p">();</span>
  <span class="c1">// 执行命令</span>
  <span class="n">command</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
</code></pre></div></div> <p>针对这种情况，我们通常会开启一个单独的线程去接收输入，而用另外的线程去处理其他计算逻辑，避免处理输入阻塞其他逻辑处理，这也是多线程的典型应用，它改变了程序的编写方式，此其二。</p> <h3 id="5-线程相关概念">5 线程相关概念</h3> <h4 id="51-时间分片">5.1 时间分片</h4> <p>CPU 先执行线程A一段时间，然后再执行线程B一段时间，然后再执行线程A一段时间，CPU 时间被切分成短的时间片、分给不同线程执行的策略就是 CPU 时间分片。时间分片是对调度策略的一个极度简化，实际上操作系统的调度策略非常精细，要比简单的时间分片复杂的多。如果一秒钟被分成大量的非常短的时间片，比如100个10毫秒的时间片，10毫秒对人的感官而言太短了，以致于用户觉察不到延迟，仿佛计算机被该用户的任务所独占（实际上并不是），操作系统通过进程的抽象获得了这种任务独占 CPU 的效果（另一个抽象是进程通过虚拟内存独占存储）。</p> <h4 id="52-上下文切换">5.2 上下文切换</h4> <p>把当前正在 CPU 上运行的任务迁走，并挑选一个新任务到 CPU 上执行的过程叫调度，任务调度的过程会发生上下文切换（context swap），即保存当前 CPU 上正在运行的线程状态，并恢复将要被执行的线程的状态，这项工作由操作系统完成，需要占用 CPU 时间（sys time）。</p> <h4 id="53-线程安全函数与可重入">5.3 线程安全函数与可重入</h4> <p>一个进程可以有多个线程在同时运行，这些线程可能同时执行一个函数，如果多线程并发执行的结果和单线程依次执行的结果是一样的，那么就是线程安全的，反之就不是线程安全的。</p> <p>不访问共享数据，共享数据包括全局变量、<code class="language-plaintext highlighter-rouge">static local</code> 变量、类成员变量，只操作参数、无副作用的函数是线程安全函数，线程安全函数可多线程重入。每个线程有独立的栈，而函数参数保存在寄存器或栈上，局部变量在栈上，所以只操作参数和局部变量的函数被多线程并发调用不存在数据竞争。</p> <p>C标准库有很多编程接口都是非线程安全的，比如时间操作/转换相关的接口：<code class="language-plaintext highlighter-rouge">ctime()</code> / <code class="language-plaintext highlighter-rouge">gmtime()</code> / <code class="language-plaintext highlighter-rouge">localtime()</code>，C标准通过提供带 _r 后缀的线程安全版本，比如：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">char</span><span class="o">*</span> <span class="nf">ctime_r</span><span class="p">(</span><span class="k">const</span> <span class="n">time</span><span class="o">*</span> <span class="n">clock</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div></div> <p>这些接口的线程安全版本，一般都需要传递一个额外的 <code class="language-plaintext highlighter-rouge">char * buf</code> 参数，这样的话，函数会操作这块 <code class="language-plaintext highlighter-rouge">buf</code>，而不是基于 <code class="language-plaintext highlighter-rouge">static</code> 共享数据，从而做到符合线程安全的要求。</p> <h4 id="54-线程私有数据">5.4 线程私有数据</h4> <p>因为全局变量（包括模块内的 <code class="language-plaintext highlighter-rouge">static</code> 变量）是进程内的所有线程共享的，但有时应用程序设计中需要提供线程私有的全局变量，这个变量仅在函数被执行的线程中有效，但却可以跨多个函数被访问。</p> <p>比如在程序里可能需要每个线程维护一个链表，而会使用相同的函数来操作这个链表，最简单的方法就是使用同名而不同变量地址的线程相关数据结构。这样的数据结构可以由 Posix 线程库维护，成为线程私有数据 (Thread-specific Data，或称为 TSD)。</p> <p>Posix 有线程私有数据相关接口，而 C/C++ 等语言提供 <code class="language-plaintext highlighter-rouge">thread_local</code> 关键字，在语言层面直接提供支持。</p> <h4 id="55-阻塞和非阻塞">5.5 阻塞和非阻塞</h4> <p>一个线程对应一个执行流，正常情况下，指令序列会被依次执行，计算逻辑会往前推进。但如果因为某种原因，一个线程的执行逻辑不能继续往前走，那么我们就说线程被阻塞住了。就像下班回家，但走到家门口发现没带钥匙，只能在门口徘徊，任由时间流逝，而不能进入房间。</p> <p>线程阻塞的原因有很多种，比如：</p> <ul> <li>线程因为 <code class="language-plaintext highlighter-rouge">acquire</code> 某个锁而被操作系统挂起，如果 <code class="language-plaintext highlighter-rouge">acquire</code> 睡眠锁失败，线程会让出 CPU，操作系统会调度另一个可运行线程到该 CPU 上执行，被调度走的线程会被加入等待队列，进入睡眠状态。</li> <li>线程调用了某个阻塞系统调用而等待，比如从没有数据到来的套接字上读数据，从空的消息队列里读消息。</li> <li>线程在循环里紧凑的执行测试&amp;设置指令并一直没有成功，虽然线程还在 CPU 上执行，但它只是忙等（相当于白白浪费 CPU），后面的指令没法执行，逻辑同样无法推进。</li> </ul> <p>如果某个系统调用或者编程接口有可能导致线程阻塞，那么便被称之为阻塞系统调用；与之对应的是非阻塞调用，调用非阻塞的函数不会陷入阻塞，如果请求的资源不能得到满足，它会立即返回并通过返回值或错误码报告原因，调用的地方可以选择重试或者返回。</p> <h2 id="多线程同步">多线程同步</h2> <p>前面讲了多线程相关的基础知识，现在进入第二个话题，多线程同步。</p> <h3 id="1-什么是多线程同步">1 什么是多线程同步</h3> <p>同一进程内的多个线程会共享数据，对共享数据的并发访问会出现 Race Condition，这个词的官方翻译是竞争条件，但 condition 翻译成条件令人困惑，特别是对初学者而言，它不够清晰明了，翻译软件显示 condition 有状况、状态的含义，可能翻译成竞争状况更直白。</p> <p>多线程同步是指：</p> <ul> <li>协调多个线程对共享数据的访问，避免出现数据不一致的情况。</li> <li>协调各个事件的发生顺序，使多线程在某个点交汇并按预期步骤往前推进，比如某线程需要等另一个线程完成某项工作才能开展该线程的下一步工作。</li> </ul> <p>要掌握多线程同步，需先理解为什么需要多线程同步、哪些情况需要同步。</p> <h3 id="2-为什么需要同步">2 为什么需要同步</h3> <p>理解为什么要<strong>同步</strong>是多线程编程的关键，它甚至比掌握多线程<strong>同步机制</strong>本身更加重要。识别什么地方需要同步是编写多线程程序的难点，只有准确识别需要保护的数据、需要同步的点，再配合系统或语言提供的合适的同步机制，才能编写安全高效的多线程程序。</p> <p>下面通过几个例子解释为什么需要同步。</p> <h4 id="示例1">示例1</h4> <p>1个长度为256的字符数组 <code class="language-plaintext highlighter-rouge">msg</code> 用于保存消息，函数 <code class="language-plaintext highlighter-rouge">read_msg()</code> 和 <code class="language-plaintext highlighter-rouge">write_msg()</code> 分别用于 <code class="language-plaintext highlighter-rouge">msg</code> 的读和写：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// example 1</span>

  <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="s">"this is old msg"</span><span class="p">;</span>

  <span class="kt">char</span><span class="o">*</span> <span class="nf">read_msg</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">msg</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">write_msg</span><span class="p">(</span><span class="kt">char</span> <span class="n">new_msg</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">memcpy</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">new_msg</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">)));</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">thread1</span><span class="p">()</span> <span class="p">{</span>
      <span class="kt">char</span> <span class="n">new_msg</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="s">"this is new msg, it's too looooooong"</span><span class="p">;</span>
      <span class="n">write_msg</span><span class="p">(</span><span class="n">new_msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new_msg</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">thread2</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"msg=%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">read_msg</span><span class="p">());</span>
  <span class="p">}</span>
</code></pre></div></div> <p>如果线程1调用 <code class="language-plaintext highlighter-rouge">write_msg()</code>，线程2调用 <code class="language-plaintext highlighter-rouge">read_msg()</code>，并发操作，不加保护。因为msg的长度是256字节，完成长达256字节的写入需要多个内存周期，在线程1写入新消息期间，线程2可能读到不一致的数据。即可能读到 “this is new msg”，而后半段内容 “it’s very…” 线程1还没来得及写入，它不是完整的新消息。</p> <p>在这个例子中，不一致表现为数据不完整。</p> <h4 id="示例2">示例2</h4> <p>比如对于二叉搜索树（BST）的节点，一个结构体有3个成分：</p> <ul> <li>一个指向父节点的指针</li> <li>一个指向左子树的指针</li> <li>一个指向右子树的指针</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// example 2</span>

  <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">Node</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">Node</span> <span class="o">*</span><span class="n">left_child</span><span class="p">,</span> <span class="o">*</span><span class="n">right_child</span><span class="p">;</span>
  <span class="p">};</span>
</code></pre></div></div> <p>这3个成分是有关联的，将节点加入 BST，要设置这3个指针域，从BST删除该节点，要修改该节点的父、左孩子节点、右孩子节点的指针域。对多个指针域的修改，不能在一个指令周期完成，如果完成了一个成分的写入，还没来得修改其他成分，就有可能被其他线程读到了，但此时节点的有些指针域还没有设置好，通过指针域去取数可能会出错。</p> <h4 id="示例3">示例3</h4> <p>考虑两个线程对同一个整型变量做自增，变量的初始值是0，我们预期2个线程完成自增后变量的值为2。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// example 3</span>

  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 初始值为0</span>
  <span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span> <span class="o">++</span><span class="n">x</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">thread2</span><span class="p">()</span> <span class="p">{</span> <span class="o">++</span><span class="n">x</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <p>简单的自增操作，包括三步：</p> <ul> <li><strong>加载</strong>：从内存中读取变量x的值存放到寄存器</li> <li><strong>更新</strong>：在寄存器里完成自增</li> <li><strong>保存</strong>：把位于寄存器中的 x 的新值写入内存</li> </ul> <p>两个线程并发执行 <code class="language-plaintext highlighter-rouge">++x</code>，让我们看看真实情况是什么样的：</p> <ol> <li>如果2个线程，先后执行自增，在时间上完成错开。无论是1先2后，或是2先1后，那么 <code class="language-plaintext highlighter-rouge">x</code> 的最终值是2，符合预期。但多线程并发并不能确保对一个变量的访问在时间上完全错开。</li> <li>如果时间上没有完全错开，假设线程1在 core1 上执行，线程2在 core2 上执行，那么，一个可能的执行过程如下： <ul> <li>首先，线程1把 <code class="language-plaintext highlighter-rouge">x</code> 读到 core1 的寄存器，线程2也把 <code class="language-plaintext highlighter-rouge">x</code> 的值加载到 core2 的寄存器，此时，存放在两个 core 的寄存器中 <code class="language-plaintext highlighter-rouge">x</code> 的副本都是0。</li> <li>然后，线程1完成自增，更新寄存器里 <code class="language-plaintext highlighter-rouge">x</code> 的值的副本（0变1），线程2也完成自增，更新寄存器里 <code class="language-plaintext highlighter-rouge">x</code> 的值的副本（0变1）。</li> <li>再然后，线程1将更新后的新值1写入变量 <code class="language-plaintext highlighter-rouge">x</code> 的内存位置。</li> <li>最后，线程2将更新后的新值1写入同一内存位置，变量 <code class="language-plaintext highlighter-rouge">x</code> 的最终值是1，不符合预期。</li> </ul> </li> </ol> <p>线程1和线程2在同一个 core 上交错执行，也有可能出现同样的问题，这个问题跟硬件结构无关。之所以会出现不符合预期的情况，主要是因为“ 加载+更新+保存 ”这3个步骤不能在一个内存周期内完成。多个线程对同一变量并发读写，不加同步的话会出现数据不一致。</p> <p>在这个例子中，不一致表现为 <code class="language-plaintext highlighter-rouge">x</code> 的终值既可能为1也可能为2。</p> <h4 id="示例4">示例4</h4> <p>用C++类模板实现一个队列：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// example 4</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">class</span> <span class="nc">Queue</span> <span class="p">{</span>
      <span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">CAPACITY</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
      <span class="n">T</span> <span class="n">elements</span><span class="p">[</span><span class="n">CAPACITY</span><span class="p">];</span>
      <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="nl">public:</span>
      <span class="c1">// 入队</span>
      <span class="kt">bool</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">CAPACITY</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
          <span class="n">tail</span> <span class="o">=</span> <span class="p">(</span><span class="o">++</span><span class="n">tail</span><span class="p">)</span> <span class="o">%</span> <span class="n">CAPACITY</span><span class="p">;</span>
          <span class="n">elements</span><span class="p">[</span><span class="n">tail</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
          <span class="o">++</span><span class="n">num</span><span class="p">;</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// 出队</span>
      <span class="kt">void</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">());</span>
          <span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="o">++</span><span class="n">head</span><span class="p">)</span> <span class="o">%</span> <span class="n">CAPACITY</span><span class="p">;</span>
          <span class="o">--</span><span class="n">num</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// 判空</span>
      <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> 
          <span class="k">return</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> 
      <span class="p">}</span>
      <span class="c1">// 访队首</span>
      <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">front</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
          <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">());</span>
          <span class="k">return</span> <span class="n">elements</span><span class="p">[</span><span class="n">head</span><span class="p">];</span>
      <span class="p">}</span>
  <span class="p">};</span>
</code></pre></div></div> <p>代码解释：</p> <ul> <li><code class="language-plaintext highlighter-rouge">T elements[]</code> 保存数据；2个游标，分别用于记录队首 <code class="language-plaintext highlighter-rouge">head</code> 和队尾 <code class="language-plaintext highlighter-rouge">tail</code> 的位置（下标）。</li> <li><code class="language-plaintext highlighter-rouge">push()</code> 接口，先移动 <code class="language-plaintext highlighter-rouge">tail</code> 游标，再把元素添加到队尾。</li> <li><code class="language-plaintext highlighter-rouge">pop()</code> 接口，移动 <code class="language-plaintext highlighter-rouge">head</code> 游标，弹出队首元素（逻辑上弹出）。</li> <li><code class="language-plaintext highlighter-rouge">front()</code> 接口，返回队首元素的引用。</li> <li><code class="language-plaintext highlighter-rouge">front()</code>、<code class="language-plaintext highlighter-rouge">pop()</code> 先做断言，调用 <code class="language-plaintext highlighter-rouge">pop()</code>/<code class="language-plaintext highlighter-rouge">front()</code> 的客户代码需确保队列非空。</li> </ul> <p>假设现在有一个 <code class="language-plaintext highlighter-rouge">Queue&lt;int&gt; </code>实例 <code class="language-plaintext highlighter-rouge">q</code>，因为直接调用 <code class="language-plaintext highlighter-rouge">pop()</code> 可能 <code class="language-plaintext highlighter-rouge">assert</code> 失败，我们封装一个 <code class="language-plaintext highlighter-rouge">try_pop()</code>，代码如下：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">try_pop</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div> <p>如果多个线程调用 <code class="language-plaintext highlighter-rouge">try_pop()</code>，会有问题，为什么？</p> <p>原因：判空+出队这2个操作，不能在一个指令周期内完成。如果线程1在判断队列非空后，线程2穿插进来，判空也为伪，这样就有可能2个线程竞争弹出唯一的元素。</p> <p>多线程环境下，读变量然后基于值做进一步操作，这样的逻辑如果不加保护就会出错，这是由数据使用方式引入的问题。</p> <h4 id="示例5">示例5</h4> <p>再看一个简单的，简单的对 <code class="language-plaintext highlighter-rouge">int32_t</code> 多线程读写。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// example 5  </span>

  <span class="kt">int32_t</span> <span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">};</span> 

  <span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
      <span class="kt">int32_t</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
      <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
      <span class="kt">int32_t</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">foo</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">thread_write1</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">v</span> <span class="o">:</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span> <span class="n">foo</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">thread_write2</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">v</span> <span class="o">:</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span> <span class="n">foo</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">thread_read</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">get</span><span class="p">());</span> <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div> <p>2个写线程1个读线程，写线程在无限循环里用 <code class="language-plaintext highlighter-rouge">data</code> 里的元素值设置 <code class="language-plaintext highlighter-rouge">foo</code> 对象的 <code class="language-plaintext highlighter-rouge">x</code> 成分，读线程简单的打印 <code class="language-plaintext highlighter-rouge">foo</code> 对象的 <code class="language-plaintext highlighter-rouge">x</code> 值。程序一直跑下去，最后打印出来的数据，会出现除 <code class="language-plaintext highlighter-rouge">data</code> 初始化值外的数据吗？</p> <p><code class="language-plaintext highlighter-rouge">Foo::get</code> 的实现有问题吗？如果有问题？是什么问题？</p> <h4 id="示例6">示例6</h4> <p>看一个用数组实现 FIFO 队列的程序，一个线程写 <code class="language-plaintext highlighter-rouge">put()</code>，一个线程读 <code class="language-plaintext highlighter-rouge">get()</code>。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// example 6</span>

  <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>  <span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
  <span class="c1">// 用数组实现的环型队列</span>
  <span class="k">class</span> <span class="nc">FIFO</span> <span class="p">{</span>
      <span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">CAPACITY</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>  <span class="c1">// 容量：需要满足是2^N</span>

      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">CAPACITY</span><span class="p">];</span>             <span class="c1">// 保存数据的缓冲区</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                        <span class="c1">// 写入位置</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                       <span class="c1">// 读取位置</span>

      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">free_space</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">CAPACITY</span> <span class="o">-</span> <span class="n">in</span> <span class="o">+</span> <span class="n">out</span><span class="p">;</span> <span class="p">}</span>
  <span class="nl">public:</span>
      <span class="c1">// 返回实际写入的数据长度（&lt;= len），返回小于len时对应空闲空间不足</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">put</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// 计算实际可写入数据长度（&lt;=len）</span>
          <span class="n">len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">free_space</span><span class="p">());</span>

          <span class="c1">// 计算从in位置到buffer结尾有多少空闲空间</span>
          <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">CAPACITY</span> <span class="o">-</span> <span class="p">(</span><span class="n">in</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CAPACITY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
          <span class="c1">// 1. 把数据放入buffer的in开始的缓冲区，最多到buffer结尾</span>
          <span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="p">(</span><span class="n">in</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CAPACITY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">src</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>   
          <span class="c1">// 2. 把数据放入buffer开头（如果上一步还没有放完），len - l为0代表上一步完成数据写入</span>
          <span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">src</span> <span class="o">+</span> <span class="n">l</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">l</span><span class="p">);</span>
          
          <span class="n">in</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// 修改in位置，累加，到达uint32_max后溢出回绕</span>
          <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// 返回实际读取的数据长度（&lt;= len），返回小于len时对应buffer数据不够</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">get</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// 计算实际可读取的数据长度</span>
          <span class="n">len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">in</span> <span class="o">-</span> <span class="n">out</span><span class="p">);</span>

          <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">CAPACITY</span> <span class="o">-</span> <span class="p">(</span><span class="n">out</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CAPACITY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
          <span class="c1">// 1. 从out位置开始拷贝数据到dst，最多拷贝到buffer结尾</span>
          <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="p">(</span><span class="n">out</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CAPACITY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">l</span><span class="p">);</span>
          <span class="c1">// 2. 从buffer开头继续拷贝数据（如果上一步还没拷贝完），len - l为0代表上一步完成数据获取</span>
          <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">l</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">l</span><span class="p">);</span>

          <span class="n">out</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// 修改out，累加，到达uint32_max后溢出回绕</span>
          <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">};</span>
</code></pre></div></div> <center> <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://p0.meituan.net/travelcube/db91961f99806e32b43699dabf6aa99f52953.png" /> </center> <p>环型队列只是逻辑上的概念，因为采用了数组作为数据结构，所以实际物理存储上并非环型。</p> <ul> <li><code class="language-plaintext highlighter-rouge">put()</code> 用于往队列里放数据，参数 <code class="language-plaintext highlighter-rouge">src+len</code> 描述了待放入的数据信息。</li> <li><code class="language-plaintext highlighter-rouge">get()</code> 用于从队列取数据，参数 <code class="language-plaintext highlighter-rouge">dst+len</code> 描述了要把数据读到哪里、以及读多少字节。</li> <li><code class="language-plaintext highlighter-rouge">capacity</code> 精心选择为2的n次方，可以得到3个好处： <br /> ** 非常技巧性的利用了无符号整型溢出回绕，便于处理对 <code class="language-plaintext highlighter-rouge">in</code> 和 <code class="language-plaintext highlighter-rouge">out</code> 移动<br /> ** 便于计算长度，通过按位与操作&amp;而不必除余<br /> ** 搜索<code class="language-plaintext highlighter-rouge"> kfifo</code> 获得更详细的解释</li> <li><code class="language-plaintext highlighter-rouge">in</code> 和 <code class="language-plaintext highlighter-rouge">out</code> 是2个游标：</li> <li><code class="language-plaintext highlighter-rouge">in</code> 用来指向新写入数据的存放位置，写入的时候，只需要简单增加 <code class="language-plaintext highlighter-rouge">in</code>。</li> <li><code class="language-plaintext highlighter-rouge">out</code> 用来指示从 <code class="language-plaintext highlighter-rouge">buffer</code> 的什么位置读取数据的，读取的时候，也只需简单增加 <code class="language-plaintext highlighter-rouge">out</code>。</li> <li><code class="language-plaintext highlighter-rouge">in</code> 和 <code class="language-plaintext highlighter-rouge">out</code> 在操作上之所以能单调增加，得益于上述 <code class="language-plaintext highlighter-rouge">capacity</code> 的巧妙选择。</li> <li>为了简化，队列容量被限制为1024字节，不支持扩容，这不影响多线程的讨论。</li> <li>写的时候，先写入数据再移动 <code class="language-plaintext highlighter-rouge">in</code> 游标；读的时候，先拷贝数据，再移动 <code class="language-plaintext highlighter-rouge">out</code> 游标；<code class="language-plaintext highlighter-rouge">in</code> 游标移动后，消费者才获得 <code class="language-plaintext highlighter-rouge">get</code> 到新放入数据的机会。</li> </ul> <p>直觉告诉我们2个线程不加同步的并发读写，会有问题，但真有问题吗？如果有，到底有什么问题？怎么解决？</p> <h3 id="3-保护什么">3 保护什么</h3> <p>多线程程序里，我们要保护的是数据而非代码，虽然 Java 等语言里有临界代码、sync方法，但最终要保护的还是代码访问的数据。</p> <h3 id="4-串行化">4 串行化</h3> <p>如果有一个线程正在访问某共享（临界）资源，那么在它结束访问之前，其他线程不能执行访问同一资源的代码（访问临界资源的代码叫临界代码），其他线程想要访问同一资源，则它必须等待，直到那个线程访问完成，它才能获得访问的机会，现实中有很多这样的例子。比如高速公路上的汽车过检查站，假设检查站只有一个车道，则无论高速路上有多少车道，过检查站的时候只能一辆车接着一辆车，从单一车道鱼贯而入。</p> <p>对多线程访问共享资源施加此种约束就叫串行化。</p> <h3 id="5-原子操作和原子变量">5 原子操作和原子变量</h3> <p>针对前面的两个线程对同一整型变量自增的问题，如果“ load、update、store ”这3个步骤是不可分割的整体，即自增操作 <code class="language-plaintext highlighter-rouge">++x</code> 满足原子性，上面的程序便不会有问题。</p> <p>因为这样的话，2个线程并发执行 <code class="language-plaintext highlighter-rouge">++x</code>，只会有2个结果：</p> <ul> <li>线程 <code class="language-plaintext highlighter-rouge">a ++x</code>，然后线程 <code class="language-plaintext highlighter-rouge">b ++x</code>，结果是2。</li> <li>线程 <code class="language-plaintext highlighter-rouge">b ++x</code>，然后线程<code class="language-plaintext highlighter-rouge"> a ++x</code>，结果是2。</li> </ul> <p>除此之外，不会出现第三种情况，线程a、b孰先孰后，取决于线程调度，但不影响最终结果。</p> <p>Linux 操作系统和 C/C++ 编程语言都提供了整型原子变量，原子变量的自增、自减等操作都是原子的，操作是原子性的，意味着它是一个不可细分的操作整体，原子变量的用户观察它，只能看到未完成和已完成2种状态，看不到半完成状态。</p> <p>如何保证原子性是实现层面的问题，应用程序员只需要从逻辑上理解原子性，并能恰当的使用它就行了。原子变量非常适用于计数、产生序列号这样的应用场景。</p> <h3 id="6-锁">6 锁</h3> <p>前面举了很多例子，阐述多线程不加同步并发访问数据会引起什么问题，下面讲解用锁如何做同步。</p> <h4 id="61-互斥锁">6.1 互斥锁</h4> <p>针对线程1 <code class="language-plaintext highlighter-rouge">write_msg()</code> + 线程2 <code class="language-plaintext highlighter-rouge">read_msg()</code> 的问题，如果能让线程1 <code class="language-plaintext highlighter-rouge">write_msg()</code> 的过程中，线程2不能 <code class="language-plaintext highlighter-rouge">read_msg()</code>，那就不会有问题。这个要求，其实就是要让多个线程互斥访问共享资源。</p> <p>互斥锁就是能满足上述要求的同步机制，互斥是排他的意思，它可以确保在同一时间，只能有一个线程对那个共享资源进行访问。</p> <p>互斥锁有且只有2种状态：</p> <ul> <li>已加锁（locked）状态</li> <li>未加锁（unlocked）状态</li> </ul> <p>互斥锁提供加锁和解锁两个接口：</p> <ul> <li><strong>加锁（acquire）</strong>：当互斥锁处于未加锁状态时，则加锁成功（把锁设置为已加锁状态），并返回；当互斥锁处于已加锁状态时，那么试图对它加锁的线程会被阻塞，直到该互斥量被解锁。</li> <li><strong>解锁（release）</strong>：通过把锁设置为未加锁状态释放锁，其他因为申请加锁而陷入等待的线程，将获得执行机会。如果有多个等待线程，只有一个会获得锁而继续执行。 我们为某个共享资源配置一个互斥锁，使用互斥锁做线程同步，那么所有线程对该资源的访问，都需要遵从“加锁、访问、解锁”的三步：</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">DataType</span> <span class="n">shared_resource</span><span class="p">;</span>
  <span class="n">Mutex</span> <span class="n">shared_resource_mutex</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">shared_resource_visitor1</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// step1: 加锁</span>
      <span class="n">shared_resource_mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
      <span class="c1">// step2: operate shared_resouce</span>
      <span class="c1">// operation1</span>
      <span class="c1">// step3: 解锁</span>
      <span class="n">shared_resource_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">shared_resource_visitor2</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// step1: 加锁</span>
      <span class="n">shared_resource_mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
      <span class="c1">// step2: operate shared_resouce</span>
      <span class="c1">// operation2</span>
      <span class="c1">// step3: 解锁</span>
      <span class="n">shared_resource_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
  <span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">shared_resource_visitor1()</code> 和 <code class="language-plaintext highlighter-rouge">shared_resource_visitor2()</code> 代表对共享资源的不同操作，多个线程可能调用同一个操作函数，也可能调用不同的操作函数。</p> <p>假设线程1执行 <code class="language-plaintext highlighter-rouge">shared_resource_visitor1()</code>，该函数在访问数据之前，申请加锁，如果互斥锁已经被其他线程加锁，则调用该函数的线程会阻塞在加锁操作上，直到其他线程访问完数据，释放（解）锁，阻塞在加锁操作的线程1才会被唤醒，并尝试加锁：</p> <ul> <li>如果没有其他线程申请该锁，那么线程1加锁成功，获得了对资源的访问权，完成操作后，释放锁。</li> <li>如果其他线程也在申请该锁，那么：<br /> ** 如果其他线程抢到了锁，那么线程1继续阻塞。<br /> ** 如果线程1抢到了该锁，那么线程1将访问资源，再释放锁，其他竞争该锁的线程得以有机会继续执行。</li> <li>如果不能承受加锁失败而陷入阻塞的代价，可以调用互斥量的 <code class="language-plaintext highlighter-rouge">try_lock()</code> 接口，它在加锁失败后会立即返回。</li> </ul> <p>注意：在访问资源前申请锁访问后释放锁，是一个编程契约，通过遵守契约而获得数据一致性的保障，它并非一种硬性的限制，即如果别的线程遵从三步曲，而另一个线程不遵从这种约定，代码能通过编译且程序能运行，但结果可能是错的。</p> <h4 id="62-读写锁">6.2 读写锁</h4> <p>读写锁跟互斥锁类似，也是申请锁的时候，如果不能得到满足则阻塞，但读写锁跟互斥锁也有不同，读写锁有3个状态：</p> <ul> <li>已加读锁状态</li> <li>已加写锁状态</li> <li>未加锁状态</li> </ul> <p>对应3个状态，读写锁有3个接口：加读锁，加写锁，解锁：</p> <ul> <li>加读锁：如果读写锁处于已加写锁状态，则申请锁的线程阻塞；否则把锁设置为已加读锁状态并成功返回。</li> <li>加写锁：如果读写锁处于未加锁状态，则把锁设置为已加写锁状态并成功返回；否则阻塞。</li> <li>解锁：把锁设置为未加锁状态后返回。</li> </ul> <p>读写锁提升了线程的并行度，可以提升吞吐。它可以让多个读线程同时读共享资源，而写线程访问共享资源的时候，其他线程不能执行，所以，读写锁适合对共享资源访问“读大于写”的场合。读写锁也叫“共享互斥锁”，多个读线程可以并发访问同一资源，这对应共享的概念，而写线程是互斥的，写线程访问资源的时候，其他线程无论读写，都不可以进入临界代码区。</p> <p>考虑一个场景：如果有线程1、2、3共享资源 <code class="language-plaintext highlighter-rouge">x</code>，读写锁 <code class="language-plaintext highlighter-rouge">rwlock</code> 保护资源，线程1读访问某资源，然后线程2以写的形式访问同一资源 <code class="language-plaintext highlighter-rouge">x</code>，因为 <code class="language-plaintext highlighter-rouge">rwlock</code> 已经被加了读锁，所以线程2被阻塞，然后过了一段时间，线程3也读访问资源 <code class="language-plaintext highlighter-rouge">x</code>，这时候线程3可以继续执行，因为读是共享的，然后线程1读访问完成，线程3继续访问，过了一段时间，在线程3访问完成前，线程1又申请读资源，那么它还是会获得访问权，但是写资源的线程2会一直被阻塞。</p> <p>为了避免共享的读线程饿死写线程，通常读写锁的实现，会给写线程优先权，当然这处决于读写锁的实现，作为读写锁的使用方，理解它的语义和使用场景就够了。</p> <h4 id="63-自旋锁">6.3 自旋锁</h4> <p>自旋锁（Spinlock）的接口跟互斥量差不多，但实现原理不同。线程在 <code class="language-plaintext highlighter-rouge">acquire</code> 自旋锁失败的时候，它不会主动让出CPU从而进入睡眠状态，而是会忙等，它会紧凑的执行测试和设置(Test-And-Set)指令，直到 TAS 成功，否则就一直占着 CPU 做 TAS。</p> <p>自旋锁对使用场景有一些期待，它期待 <code class="language-plaintext highlighter-rouge">acquire</code> 自旋锁成功后很快会 <code class="language-plaintext highlighter-rouge">release</code> 锁，线程运行临界区代码的时间很短，访问共享资源的逻辑简单，这样的话，别的 <code class="language-plaintext highlighter-rouge">acquire</code> 自旋锁的线程只需要忙等很短的时间就能获得自旋锁，从而避免被调度走陷入睡眠，它假设自旋的成本比调度的低，它不愿耗费时间在线程调度上（线程调度需要保存和恢复上下文需要耗费CPU）。</p> <p>内核态线程很容易满足这些条件，因为运行在内核态的中断处理函数里可以通过关闭调度，从而避免 CPU 被抢占，而且有些内核态线程调用的处理函数不能睡眠，只能使用自旋锁。</p> <p>而运行在用户态的应用程序，则推荐使用互斥锁等睡眠锁。因为运行在用户态应用程序，虽然很容易满足临界区代码简短，但持有锁时间依然可能很长。在分时共享的多任务系统上、当用户态线程的时间配额耗尽，或者在支持抢占式的系统上、有更高优先级的任务就绪，那么持有自旋锁的线程就会被系统调度走，这样持有锁的过程就有可能很长，而忙等自旋锁的其他线程就会白白消耗 CPU 资源，这样的话，就跟自旋锁的理念相背。</p> <p>Linux 系统优化过后的 <code class="language-plaintext highlighter-rouge">mutex</code> 实现，在加锁的时候会先做有限次数的自旋，只有有限次自旋失败后，才会进入睡眠让出 CPU，所以，实际使用中，它的性能也足够好。此外，自旋锁必须在多 CPU 或者多 Core 架构下，试想如果只有一个核，那么它执行自旋逻辑的时候，别的线程没有办法运行，也就没有机会释放锁。</p> <h4 id="64-锁的粒度">6.4 锁的粒度</h4> <p>合理设置锁的粒度，粒度太大会降低性能，太小会增加代码编写复杂度。</p> <h4 id="65-锁的范围">6.5 锁的范围</h4> <p>锁的范围要尽量小，最小化持有锁的时间。</p> <h4 id="66-死锁">6.6 死锁</h4> <p>程序出现死锁有两种典型原因：</p> <p><strong>ABBA 锁</strong></p> <p>假设程序中有2个资源 X 和 Y，分别被锁 A 和 B 保护，线程1持有锁 A 后，想要访问资源 Y，而访问资源 Y 之前需要申请锁 B，而如果线程2正持有锁 B，并想要访问资源 X，为了访问资源 X，所以线程2需要申请锁 A。线程1和线程2分别持有锁 A 和 B，并都希望申请对方持有的锁，因为线程申请对方持有的锁，得不到满足，所以便会陷入等待，也就没有机会释放自己持有的锁，对方执行流也就没有办法继续前进，导致相持不下，无限互等，进而死锁。</p> <p>上述的情况似乎很明显，但如果代码量很大，有时候，这种死锁的逻辑不会这么浅显，它被复杂的调用逻辑所掩盖，但抽茧剥丝，最根本的逻辑就是上面描述的那样。这种情况叫 ABBA 锁，既某个线程持有A锁申请B锁，而另一个线程持有 B 锁申请 A 锁。这种情况可以通过 <code class="language-plaintext highlighter-rouge">try lock</code> 实现，尝试获取锁，如果不成功，则释放自己持有的锁，而不一根筋下去。另一种解法就是锁排序，对A/B两把锁的加锁操作，都遵从同样的顺序（比如先 A 后 B），也能避免死锁。</p> <p><strong>自死锁</strong></p> <p>对于不支持重复加锁的锁，如果线程持有某个锁，而后又再次申请锁，因为该锁已经被自己持有，再次申请锁必然得不到满足，从而导致死锁。</p> <h3 id="7-条件变量">7 条件变量</h3> <p>条件变量常用于生产者消费者模式，需配合互斥量使用。</p> <p>假设你要编写一个网络处理程序，I/O 线程从套接字接收字节流，反序列化后产生一个个消息（自定义协议），然后投递到一个消息队列，一组工作线程负责从消息队列取出并处理消息。这是典型的生产者-消费者模式，I/O 线程生产消息（往队列put），Work线程消费消息（从队列get），I/O 线程和 Work 线程并发访问消息队列，显然，消息队列是竞争资源，需要同步。</p> <center> <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://p0.meituan.net/travelcube/fb99fb443c76b32cb536646eda91dfa731825.png" /> </center> <p>可以给队列配置互斥锁，put 和 get 操作前都先加锁，操作完成再解锁。代码差不多是这样的：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">io_thread</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">read_msg_from_socket</span><span class="p">();</span>
          <span class="n">msg_queue_mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
          <span class="n">msg_queue</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
          <span class="n">msg_queue_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">work_thread</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">msg_queue_mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
          <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">msg_queue</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
          <span class="n">msg_queue_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">process</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div> <p>work 线程组的每个线程都忙于检查消息队列是否有消息，如果有消息就取一个出来，然后处理消息，如果没有消息就在循环里不停检查，这样的话，即使负载很轻，但 <code class="language-plaintext highlighter-rouge">work_thread</code> 还是会消耗大量的CPU时间。</p> <p>我们当然可以在两次查询之间加入短暂的 sleep，从而让出 CPU，但是这个睡眠的时间设置为多少合适呢？设置长了的话，会出现消息到来得不到及时处理（延迟上升）；设置太短了，还是无辜消耗了 CPU 资源，这种不断问询的方式在编程上叫轮询。</p> <p>轮询行为逻辑上，相当于你在等一个投递到楼下小邮局的包裹，你下楼查验没有之后就上楼回房间，然后又下楼查验，你不停的上下楼查验，其实大可不必如此，何不等包裹到达以后，让门卫打电话通知你去取呢？</p> <p>条件变量提供了一种类似通知 notify 的机制，它让两类线程能够在一个点交汇。条件变量能够让线程等待某个条件发生，条件本身受互斥锁保护，因此条件变量必须搭配互斥锁使用，锁保护条件，线程在改变条件前先获得锁，然后改变条件状态，再解锁，最后发出通知，等待条件的睡眠中的线程在被唤醒前，必须先获得锁，再判断条件状态，如果条件不成立，则继续转入睡眠并释放锁。</p> <p>对应到上面的例子，工作线程等待的条件是消息队列有消息（非空），用条件变量改写上面的代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">io_thread</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">read_msg_from_socket</span><span class="p">();</span>
          <span class="p">{</span>
              <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">msg_queue_mutex</span><span class="p">);</span>
              <span class="n">msg_queue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="n">msg_queue_not_empty</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">work_thread</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
          <span class="p">{</span>
              <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">msg_queue_mutex</span><span class="p">);</span>
              <span class="n">msg_queue_not_empty</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[]{</span> <span class="k">return</span> <span class="o">!</span><span class="n">msg_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>
              <span class="n">msg</span> <span class="o">=</span> <span class="n">msg_queue</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
          <span class="p">}</span>
          <span class="n">process</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">std::lock_guard</code> 是互斥量的一个RAII包装类，<code class="language-plaintext highlighter-rouge">std::unique_lock</code> 除了会在析构函数自动解锁外，还支持主动 <code class="language-plaintext highlighter-rouge">unlock()</code>。</p> <p>生产者在往 <code class="language-plaintext highlighter-rouge">msg_queue</code> 投递消息的时候，需要对 <code class="language-plaintext highlighter-rouge">msg_queue</code> 加锁，通知 work 线程的代码可以放在解锁之后，等待 <code class="language-plaintext highlighter-rouge">msg_queue_not_empty</code> 条件必须受 <code class="language-plaintext highlighter-rouge">msg_queue_mutex</code> 保护，<code class="language-plaintext highlighter-rouge">wait()</code> 的第二个参数是一个 <code class="language-plaintext highlighter-rouge">lambda</code> 表达式，因为会有多个 work 线程被唤醒，线程被唤醒后，会重新获得锁，检查条件，如果不成立，则再次睡眠。条件变量的使用需要非常谨慎，否则容易出现不能唤醒的情况。</p> <p>C语言的条件变量、Posix 条件变量的编程接口跟 C++ 的类似，概念上是一致的，故在此不展开介绍。</p> <h3 id="8-lock-free-和无锁数据结构">8 Lock-free 和无锁数据结构</h3> <h4 id="81-锁同步的问题">8.1 锁同步的问题</h4> <p>线程同步分为阻塞型同步和非阻塞型同步。</p> <p>互斥量、信号、条件变量这些系统提供的机制都属于阻塞型同步，在争用资源的时候，会导致调用线程阻塞。 非阻塞型同步是指在无锁的情况下，通过某种算法和技术手段实现不用阻塞而同步。 锁是阻塞同步机制，阻塞同步机制的缺陷是可能挂起你的程序，如果持有锁的线程崩溃或者 hang 住，则锁永远得不到释放，而其他线程则将陷入无限等待；另外，它也可能导致优先级倒转等问题。所以，我们需要 Lock-free 这类非阻塞的同步机制。</p> <h4 id="82-什么是-lock-free">8.2 什么是 Lock-free</h4> <p>Lock-free 没有锁同步的问题，所有线程无阻碍的执行原子指令，而不是等待。比如一个线程读 <code class="language-plaintext highlighter-rouge">atomic</code> 类型变量，一个线程写 <code class="language-plaintext highlighter-rouge">atomic</code> 变量，它们没有任何等待，硬件原子指令确保不会出现数据不一致，写入数据不会出现半完成，读取数据也不会读一半。</p> <p>那到底什么是 Lock-free？有人说 Lock-free 就是不使用 <code class="language-plaintext highlighter-rouge">mutex</code> / <code class="language-plaintext highlighter-rouge">semaphores</code> 之类的无锁（Lock-Less）编程，这句话严格来说并不对。</p> <p>我们先看一下 wiki 对 Lock-free 的描述:</p> <blockquote> <p>Lock-freedom allows individual threads to starve but guarantees system-wide throughput. An algorithm is Lock-free if, when the program threads are run for a sufficiently long time, at least one of the threads makes progress (for some sensible definition of progress). All wait-free algorithms are Lock-free. In particular, if one thread is suspended, then a Lock-free algorithm guarantees that the remaining threads can still make progress. Hence, if two threads can contend for the same mutex lock or spinlock, then the algorithm is not Lock-free. (If we suspend one thread that holds the lock, then the second thread will block.)</p> </blockquote> <p>翻译一下：</p> <ul> <li>第1段：Lock-free 允许单个线程饥饿但保证系统级吞吐。如果一个程序线程执行足够长的时间，那么至少一个线程会往前推进，那么这个算法就是Lock-free的。</li> <li>第2段：尤其是，如果一个线程被暂停，Lock-free 算法保证其他线程依然能够往前推进。</li> </ul> <p>第1段给 Lock-free 下定义，第2段则是对 Lock-free 作解释：如果2个线程竞争同一个互斥锁或者自旋锁，那它就不是 Lock-free 的；因为如果暂停（Hang）持有锁的线程，那么另一个线程会被阻塞。</p> <p>wiki 的这段描述很抽象，它不够直观，稍微再解释一下：Lock-free 描述的是代码逻辑的属性，不使用锁的代码，大部分具有这种属性。大家经常会混淆这 Lock-free 和无锁这2个概念。其实，Lock-free 是对代码（算法）性质的描述，是属性；而无锁是说代码如何实现，是手段。</p> <p>Lock-free 的关键描述是：如果一个线程被暂停，那么其他线程应能继续前进，它需要有系统级（system-wide）的吞吐。</p> <p>如图，两个线程在时间线上，至少有一个线程处于 running 状态。</p> <center> <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://p1.meituan.net/travelcube/5b45d715f8b8e6576d9e841a9a4c4bd1217086.png" /> </center> <p>我们从反面举例来看，假设我们要借助锁实现一个无锁队列，我们可以直接使用线程不安全的 <code class="language-plaintext highlighter-rouge">std::queue</code> + <code class="language-plaintext highlighter-rouge">std::mutex</code> 来做：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">class</span> <span class="nc">Queue</span> <span class="p">{</span>
  <span class="nl">public:</span>
      <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">q_mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
          <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
          <span class="n">q_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
      <span class="p">}</span>
  <span class="nl">private:</span>
      <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">q_mutex</span><span class="p">;</span>
  <span class="p">};</span>
</code></pre></div></div> <p>如果有线程 A/B/C 同时执行 <code class="language-plaintext highlighter-rouge">push()</code> 方法，最先进入的线程 A 获得互斥锁。线程 B 和 C 因为获取不到互斥锁而陷入等待。这个时候，线程 A 如果因为某个原因（如出现异常，或者等待某个资源）而被永久挂起，那么同样执行 <code class="language-plaintext highlighter-rouge">push()</code> 的线程 B/C 将被永久挂起，系统整体（system-wide）没法推进，而这显然不符合 Lock-free 的要求。因此：所有基于锁（包括 spinlock ）的并发实现，都不是 Lock-free 的。</p> <p>因为它们都会遇到同样的问题：即如果永久暂停当前占有锁的线程/进程的执行，将会阻塞其他线程/进程的执行。而对照 Lock-free 的描述，它允许部分 process（理解为执行流）饿死但必须保证整体逻辑的持续前进，基于锁的并发显然是违背 Lock-free 要求的。</p> <h4 id="83-cas-loop-实现-lock-free">8.3 CAS loop 实现 Lock-free</h4> <p>Lock-free 同步主要依靠 CPU 提供的 <code class="language-plaintext highlighter-rouge">read-modify-write</code> 原语，著名的“比较和交换“ CAS（Compare And Swap）在 X86 机器上是通过 <code class="language-plaintext highlighter-rouge">cmpxchg</code> 系列指令实现的原子操作，CAS 逻辑上用代码表达是这样的：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">bool</span> <span class="nf">CAS</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">T</span> <span class="n">expect_value</span><span class="p">,</span> <span class="n">T</span> <span class="n">new_value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">!=</span> <span class="n">expect_value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div> <p>CAS 接受3个参数：</p> <p>内存地址 期望值，通常传第一个参数所指内存地址中的旧值 新值 逻辑描述：CAS 比较内存地址中的值和期望值，如果不相同就返回失败，如果相同就将新值写入内存并返回成功。</p> <p>当然这个C函数描述的只是 CAS 的逻辑，这个函数操作不是原子的，因为它可以划分成几个步骤：读取内存值、判断、写入新值，各步骤之间是可以插入其他操作的。不过前面讲了，原子指令相当于把这些步骤打包，它可能是通过 <code class="language-plaintext highlighter-rouge">lock:cmpxchg</code> 指令实现的，但那是实现细节，程序员更应该注重在逻辑上理解它的行为。</p> <p>通过 CAS 实现 Lock-free 的代码通常借助循环，代码如下：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">do</span> <span class="p">{</span>
      <span class="n">T</span> <span class="n">expect_value</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">CAS</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">expect_value</span><span class="p">,</span> <span class="n">new_value</span><span class="p">));</span>
</code></pre></div></div> <p>创建共享数据的本地副本：<code class="language-plaintext highlighter-rouge">expect_value</code>。 根据需要修改本地副本，从 <code class="language-plaintext highlighter-rouge">ptr</code> 指向的共享数据里 <code class="language-plaintext highlighter-rouge">load</code> 后赋值给 <code class="language-plaintext highlighter-rouge">expect_value</code>。 检查共享的数据跟本地副本是否相等，如果相等，则把新值复制到共享数据。 第三步是关键，虽然CAS是原子的，但加载 <code class="language-plaintext highlighter-rouge">expect_value</code> 跟 CAS 这2个步骤，并不是原子的。所以，我们需要借助循环，如果ptr内存位置的值没有变（<code class="language-plaintext highlighter-rouge">*ptr \== expect_value</code>），那就存入新值返回成功；否则说明加载 <code class="language-plaintext highlighter-rouge">expect_value</code> 后，<code class="language-plaintext highlighter-rouge">ptr</code> 指向的内存位置被其他线程修改了，这时候就返回失败，重新加载 <code class="language-plaintext highlighter-rouge">expect_value</code> ，重试，直到成功为止。</p> <p>CAS loop 支持多线程并发写，这个特点太有用了，因为多线程同步，很多时候都面临多写的问题，我们可以基于 CAS 实现 Fetch-and-add(FAA)算法，它看起来像这样：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">T</span> <span class="nf">faa</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">T</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">compare_and_swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">temp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
  <span class="p">}</span>
</code></pre></div></div> <p>第一步加载共享数据的值到 <code class="language-plaintext highlighter-rouge">temp</code>，第二步比较 + 存入新值，直到成功。</p> <h4 id="84-无锁数据结构lock-free-stack">8.4 无锁数据结构：Lock-free Stack</h4> <p>无锁数据结构是通过非阻塞算法而非锁保护共享数据，非阻塞算法保证竞争共享资源的线程，不会因为互斥而让它们的执行无限期暂停；无阻塞算法是 Lock-free 的，因为无论如何调度都能确保有系统级的进度。wiki 定义如下：</p> <blockquote> <p>A non-blocking algorithm ensures that threads competing for a shared resource do not have their execution indefinitely postponed by mutual exclusion. A non-blocking algorithm is Lock-free if there is guaranteed system-wide progress regardless of scheduling.</p> </blockquote> <p>下面是 C++ <code class="language-plaintext highlighter-rouge">atomic compare_exchange_weak()</code> 实现的一个 Lock-free 堆栈（from CppReference）：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">node</span> <span class="p">{</span>
      <span class="n">T</span> <span class="n">data</span><span class="p">;</span>
      <span class="n">node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
      <span class="n">node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
  <span class="p">};</span>
  
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">class</span> <span class="nc">stack</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span> <span class="n">head</span><span class="p">;</span>
  <span class="nl">public:</span>
      <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">new_node</span><span class="p">,</span>
                                          <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">,</span>
                                          <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">));</span>
      <span class="p">}</span>
  <span class="p">};</span>
</code></pre></div></div> <p>代码解析：</p> <ul> <li>节点（<code class="language-plaintext highlighter-rouge">node</code>）保存 <code class="language-plaintext highlighter-rouge">T</code> 类型的数据 <code class="language-plaintext highlighter-rouge">data</code>，并且持有指向下一个节点的指针。</li> <li><code class="language-plaintext highlighter-rouge">std::atomic&lt;node*&gt;</code> 类型表明 <code class="language-plaintext highlighter-rouge">atomic</code> 里放置的是 Node 的指针，而非 <code class="language-plaintext highlighter-rouge">Node</code> 本身，因为指针在64位系统上是8字节，等于机器字长，再长没法保证原子性。</li> <li><code class="language-plaintext highlighter-rouge">stack</code> 类包含 <code class="language-plaintext highlighter-rouge">head</code> 成员，<code class="language-plaintext highlighter-rouge">head</code> 是一个指向头结点的指针，头结点指针相当于堆顶指针，刚开始没有节点，<code class="language-plaintext highlighter-rouge">head</code> 为 <code class="language-plaintext highlighter-rouge">NULL</code>。</li> <li><code class="language-plaintext highlighter-rouge">push</code> 函数里，先根据 <code class="language-plaintext highlighter-rouge">data</code> 值创建新节点，然后要把它放到堆顶。</li> <li>因为是用链表实现的栈，所以，如果新节点要成为新的堆顶（相当于新节点作为新的头结点插入），那么新节点的 <code class="language-plaintext highlighter-rouge">next</code> 域要指向原来的头结点，并让 <code class="language-plaintext highlighter-rouge">head</code> 指向新节点。</li> <li><code class="language-plaintext highlighter-rouge">new_node-&gt;next = head.load</code> 把新节点的 <code class="language-plaintext highlighter-rouge">next</code> 域指向原头结点，然后 <code class="language-plaintext highlighter-rouge">head.compare_exchange_weak(new_node-&gt;next, new_node)</code>，让 <code class="language-plaintext highlighter-rouge">head</code> 指向新节点。</li> <li>C++ <code class="language-plaintext highlighter-rouge">atomic</code> 的 <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code> 跟上述的 CAS 稍有不同，<code class="language-plaintext highlighter-rouge">head.load()</code> 不等于 <code class="language-plaintext highlighter-rouge">new_node-&gt;next</code> 的时候，它会把 <code class="language-plaintext highlighter-rouge">head.load()</code> 的值重新加载到 <code class="language-plaintext highlighter-rouge">new_node-&gt;next</code>。</li> <li>所以，在加载 <code class="language-plaintext highlighter-rouge">head</code> 值和 CAS 之间，如果其他线程调用 <code class="language-plaintext highlighter-rouge">push</code> 操作，改变了head的值，那没有关系，该线程的本次 cas 失败，下次重试便可以了。</li> <li>多个线程同时 <code class="language-plaintext highlighter-rouge">push</code> 时，任一线程在任意步骤阻塞/挂起，其他线程都会继续执行并最终返回，无非就是多执行几次 <code class="language-plaintext highlighter-rouge">while</code> 循环。</li> </ul> <p>这样的行为逻辑显然符合 Lock-free 的定义，注意用 CAS+Loop 实现自旋锁不符合 Lock-free 的定义，注意区分。</p> <h3 id="9-程序序program-order">9 程序序：Program Order</h3> <p>对单线程程序而言，代码会一行行顺序执行，就像我们编写的程序的顺序那样。比如：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div> <p>会先执行 <code class="language-plaintext highlighter-rouge">a = 1</code> 再执行 <code class="language-plaintext highlighter-rouge">b = 2</code>，从程序角度看到的代码行依次执行叫程序序，我们在此基础上构建软件，并以此作为讨论的基础。</p> <h3 id="10-内存序memory-order">10 内存序：Memory Order</h3> <p>与程序序相对应的内存序，是指从某个角度观察到的对于内存的读和写所真正发生的顺序。内存操作顺序并不唯一，在一个包含 core0 和 core1 的 CPU 中，core0 和 core1 有着各自的内存操作顺序，这两个内存操作顺序不一定相同。从包含多个 Core 的 CPU 的视角看到的全局内存操作顺序跟单 core 视角看到的内存操作顺序亦不同，而这种不同，对于有些程序逻辑而言，是不可接受的，例如：</p> <p>程序序要求 <code class="language-plaintext highlighter-rouge">a = 1</code> 在 <code class="language-plaintext highlighter-rouge">b = 2</code> 之前执行，但内存操作顺序可能并非如此，对 a 赋值1并不确保发生在对 b 赋值2之前，这是因为：</p> <ul> <li>如果编译器认为对 b 赋值没有依赖对 a 赋值，那它完全可能在编译期调整编译后的汇编指令顺序。</li> <li>即使编译器不做调整，到了执行期，也有可能对 b 的赋值先于对 a 赋值执行。</li> </ul> <p>虽然对一个 Core 而言，如上所述，这个 Core 观察到的内存操作顺序不一定符合程序序，但内存操作序和程序序必定产生相同的结果，无论在单 Core 上对 a、b 的赋值哪个先发生，结果上都是 a 被赋值为1、b 被赋值为2，如果单核上乱序执行会影响结果，那编译器的指令重排和 CPU 乱序执行便不会发生，硬件会提供这项保证。</p> <p>但多核系统，硬件不提供这样的保证，多线程程序中，每个线程所工作的 Core 观察到的不同内存操作序，以及这些顺序与全局内存序的差异，常常导致多线程同步失败，所以，需要有同步机制确保内存序与程序序的一致，内存屏障（Memory Barrier）的引入，就是为了解决这个问题，它让不同的 Core 之间，以及 Core 与全局内存序达成一致。</p> <h3 id="11-乱序执行out-of-order-execution">11 乱序执行：Out-of-Order Execution</h3> <p>乱序执行会引起内存顺序跟程序顺序不同，乱序执行的原因是多方面的，比如编译器指令重排、超标量指令流水线、预测执行、Cache-Miss 等。内存操作顺序无法精确匹配程序顺序，这有可能带来混乱，既然有副作用，那为什么还需要乱序执行呢？答案是为了性能。</p> <p>我们先看看没有乱序执行之前，早期的有序处理器（In-order Processors）是怎么处理指令的？</p> <ul> <li>指令获取，从代码节内存区域加载指令到 I-Cache</li> <li>译码</li> <li>如果指令操作数可用（例如操作数位于寄存器中），则分发指令到对应功能模块中；如果操作数不可用，通常是需要从内存加载，则处理器会 stall，一直等到它们就绪，直到数据被加载到 Cache 或拷贝进寄存器</li> <li>指令被功能单元执行</li> <li>功能单元将结果写回寄存器或内存位置</li> </ul> <p><strong>乱序处理器（Out-of-Order Processors）</strong>又是怎么处理指令的呢？</p> <ul> <li>指令获取，从代码节内存区域加载指令到 I-Cache</li> <li>译码</li> <li>分发指令到指令队列</li> <li>指令在指令队列中等待，一旦操作数就绪，指令就离开指令队列，那怕它之前的指令未被执行（乱序）</li> <li>指令被派往功能单元并被执行</li> <li>执行结果放入队列（Store Buffer），而不是直接写入 Cache</li> <li>只有更早请求执行的指令结果写入 Cache 后，指令执行结果才写入 Cache，通过对指令结果排序写入 Cache，使得执行看起来是有序的</li> </ul> <p>指令乱序执行是结果，但原因并非只有 CPU 的乱序执行，而是由两种因素导致：</p> <ul> <li><strong>编译期</strong>：指令重排（编译器），编译器会为了性能而对指令重排，源码上先后的两行，被编译器编译后，可能调换指令顺序，但编译器会基于一套规则做指令重排，有明显依赖的指令不会被随意重排，指令重排不能破坏程序逻辑。</li> <li><strong>运行期</strong>：乱序执行（CPU），CPU 的超标量流水线、以及预测执行、Cache-Miss 等都有可能导致指令乱序执行，也就是说，后面的指令有可能先于前面的指令执行。</li> </ul> <h3 id="12-store-buffer">12 Store Buffer</h3> <p>为什么需要 Store Buffer？</p> <p>考虑下面的代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set_a</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>假设运行在 core0 上的 set_a() 对整型变量 a 赋值1，计算机通常不会直接写穿通到内存，而是会在 Cache 中修改对应 Cache Line</li> <li>如果 Core0 的 Cache 里没有a，赋值操作（store）会造成 Cache Miss</li> <li>Core0 会 stall 在等待 Cache 就绪（从内存加载变量 a 到对应的Cache Line），但Stall会损害CPU性能，相当于CPU在这里停顿，白白浪费着宝贵的 CPU 时间</li> <li>有了 Store Buffer，当变量在 Cache 中没有就位的时候，就先 Buffer 住这个 Store 操作，而 Store 操作一旦进入 Store Buffer，core 便认为自己 Store完成，当随后 Cache 就位，store 会自动写入对应 Cache。</li> </ul> <p>所以，我们需要 Store Buffer，每个 Core 都有独立的 Store Buffer，每个 Core 都访问私有的 Store Buffer，Store Buffer 帮助 CPU 遮掩了 Store 操作带来的延迟。</p> <p>Store Buffer 会带来什么问题？</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div> <p>上面的代码，断言 <code class="language-plaintext highlighter-rouge">a == 1</code> 的时候，需要读（load）变量a的值，而如果 a 在被赋值前就在 Cache 中，就会从 Cache 中读到 a 的旧值（可能是1之外的其他值），所以断言就可能失败。但这样的结果显然是不能接受的，它违背了最直观的程序顺序性。</p> <p>问题出在变量 a 除保存在内存外，还有2份拷贝：一份在 Store Buffer 里，一份在 Cache 里；如果不考虑这2份拷贝的关系，就会出现数据不一致。那怎么修复这个问题呢？</p> <p>可以通过在 Core Load 数据的时候，先检查 Store Buffer 中是否有悬而未决的a的新值，如果有，则取新值；否则从 cache 取 a 的副本。这种技术在多级流水线 CPU 设计的时候就经常使用，叫 Store Forwarding。有了 Store Buffer Forwarding，就能确保单核程序的执行遵从程序顺序性，但多核还是有问题，让我们考查下面的程序：</p> <p>多核内存序问题</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 被CPU1 Cache</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 被CPU0 Cache</span>

  <span class="c1">// CPU0执行</span>
  <span class="kt">void</span> <span class="nf">x</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// CPU1执行</span>
  <span class="kt">void</span> <span class="n">y</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div> <p>假设 a 和 b 都被初始化为0；CPU0 执行 <code class="language-plaintext highlighter-rouge">x()</code> 函数，CPU1 执行 <code class="language-plaintext highlighter-rouge">y() </code>函数；变量 a 在 CPU1 的 local Cache里，变量 b 在 CPU0 的 local Cache 里。</p> <ul> <li>CPU0 执行 <code class="language-plaintext highlighter-rouge">a = 1</code> 的时候，因为 a 不在 CPU0 的 local cache，CPU0 会把 a 的新值1写入 Store Buffer 里，并发送 Read Invalidate 消息给其他 CPU。</li> <li>CPU1 执行 <code class="language-plaintext highlighter-rouge">while (b == 0)</code>，因为 b 不在 CPU1 的 local cache 里，CPU1 会发送 Read 消息去其他 CPU 获取 b 的值。</li> <li>CPU0 执行 <code class="language-plaintext highlighter-rouge">b = 2</code>，因为 b 在 CPU0 的 local Cache，所以直接更新 local cache 中 b 的副本。</li> <li>CPU0 收到 CPU1 发来的 read 消息，把 b 的新值2发送给 CPU1；同时存放 b 的 Cache Line 的状态被设置为 Shared，以反应 b 同时被 CPU0 和 CPU1 cache 住的事实。</li> <li>CPU1 收到 b 的新值2后结束循环，继续执行 <code class="language-plaintext highlighter-rouge">assert(a == 1)</code>，因为此时 local Cache 中的 a 值为0，所以断言失败。</li> <li>CPU1 收到 CPU0 发来的 Read Invalidate 后，更新 a 的值为1，但为时已晚，程序在上一步已经崩了（assert失败）。</li> </ul> <p>怎么办？答案留到内存屏障一节揭晓。</p> <h3 id="13-invalidate-queue">13 Invalidate Queue</h3> <p>为什么需要 Invalidate Queue？</p> <p>当一个变量加载到多个 core 的 Cache，则这个 Cache Line 处于 Shared 状态，如果 Core1 要修改这个变量，则需要通过发送核间消息 Invalidate 来通知其他 Core 把对应的 Cache Line 置为 Invalid，当其他 Core 都 Invalid 这个 CacheLine 后，则本 Core 获得该变量的独占权，这个时候就可以修改它了。</p> <p>收到 Invalidate 消息的 core 需要回 Invalidate ACK，一个个 core 都这样 ACK，等所有 core 都回复完，Core1 才能修改它，这样 CPU 就白白浪费。</p> <p>事实上，其他核在收到 Invalidate 消息后，会把I nvalidate 消息缓存到 Invalidate Queue，并立即回复 ACK，真正 Invalidate 动作可以延后再做，这样一方面因为 Core 可以快速返回别的 Core 发出的 Invalidate 请求，不会导致发生 Invalidate 请求的 Core 不必要的 Stall，另一方面也提供了进一步优化可能，比如在一个 CacheLine 里的多个变量的 Invalidate 可以攒一次做了。</p> <p>但写 Store Buffer 的方式其实是 Write Invalidate，它并非立即写入内存，如果其他核此时从内存读数，则有可能不一致。</p> <h3 id="14-内存屏障">14 内存屏障</h3> <p>那有没有方法确保对 a 的赋值一定先于对 b 的赋值呢？有，内存屏障被用来提供这个保障。</p> <p>内存屏障（Memory Barrier），也称内存栅栏、屏障指令等，是一类同步屏障指令，是 CPU 或编译器在对内存随机访问的操作中的一个同步点，同步点之前的所有读写操作都执行后，才可以开始执行此点之后的操作。语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。</p> <p>内存屏障，其实就是提供一种机制，确保代码里顺序写下的多行，会按照书写的顺序，被存入内存，主要是解决 Store Buffer 引入导致的写入内存间隙的问题。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">x</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">wmb</span><span class="p">();</span>
      <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div> <p>像上面那样在 <code class="language-plaintext highlighter-rouge">a = 1</code> 和 <code class="language-plaintext highlighter-rouge">b = 2</code> 之间插入一条内存屏障语句，就能确保 <code class="language-plaintext highlighter-rouge">a = 1</code> 先于 <code class="language-plaintext highlighter-rouge">b = 2</code> 生效，从而解决了内存乱序访问问题，那插入的这句 <code class="language-plaintext highlighter-rouge">smp_mb()</code>，到底会干什么呢？</p> <p>回忆前面的流程，CPU0 在执行完 <code class="language-plaintext highlighter-rouge">a = 1</code> 之后，执行 <code class="language-plaintext highlighter-rouge">smp_mb()</code> 操作，这时候，它会给 Store Buffer 里的所有数据项做一个标记（marked），然后继续执行 <code class="language-plaintext highlighter-rouge">b = 2</code>，但这时候虽然 b 在自己的 cache 里，但由于 store buffer 里有 marked 条目，所以，CPU0 不会修改 cache 中的 b，而是把它写入 Store Buffer；所以 CPU0 收到 Read 消息后，会把 b 的0值发给 CPU1，所以继续在 <code class="language-plaintext highlighter-rouge">while (b)</code> 自旋。</p> <p>简而言之，Core 执行到 write memory barrier（wmb）的时候，如果 Store Buffer 还有悬而未决的 store 操作，则都会被 mark 上，直到被标注的 Store 操作进入内存后，后续的 Store 操作才能被执行，因此 <code class="language-plaintext highlighter-rouge">wmb</code> 保障了 barrier 前后操作的顺序，它不关心 barrier 前的多个操作的内存序，以及 barrier 后的多个操作的内存序，是否与 Global Memory Order 一致。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">wmb</span><span class="p">();</span>
  <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="n">d</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">wmb()</code> 保证“<code class="language-plaintext highlighter-rouge">a = 1;b = 2</code>”发生在“<code class="language-plaintext highlighter-rouge">c = 3;d = 4</code>”之前，不保证 <code class="language-plaintext highlighter-rouge">a = 1</code> 和 <code class="language-plaintext highlighter-rouge">b = 2</code> 的内存序，也不保证 <code class="language-plaintext highlighter-rouge">c = 3</code> 和 <code class="language-plaintext highlighter-rouge">d = 4</code> 的内部序。</p> <p>Invalidate Queue 的引入的问题</p> <p>就像引入 Store Buffer 会影响 Store 的内存一致性，Invalidate Queue 的引入会影响 Load 的内存一致性。因为 Invalidate queue 会缓存其他核发过来的消息，比如 Invalidate 某个数据的消息被 <code class="language-plaintext highlighter-rouge">delay</code> 处置，导致 core 在 Cache Line 中命中这个数据，而这个 Cache Line 本应该被 Invalidate 消息标记无效。如何解决这个问题呢？</p> <p>一种思路是硬件确保每次load数据的时候，需要确保 Invalidate Queue 被清空，这样可以保证 load 操作的强顺序</p> <p>软件的思路，就是仿照 <code class="language-plaintext highlighter-rouge">wmb()</code> 的定义，加入 <code class="language-plaintext highlighter-rouge">rmb()</code> 约束。<code class="language-plaintext highlighter-rouge">rmb()</code> 给我们的 invalidate queue 加上标记。当一个 load 操作发生的时候，之前的 <code class="language-plaintext highlighter-rouge">rmb()</code> 所有标记的 invalidate 命令必须全部执行完成，然后才可以让随后的 load 发生。这样，我们就在 <code class="language-plaintext highlighter-rouge">rmb()</code> 前后保证了 load 观察到的顺序等同于 global memory order</p> <p>所以，我们可以像下面这样修改代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">wmb</span><span class="p">();</span>
  <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{};</span>
  <span class="n">rmb</span><span class="p">();</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div> <p><strong>系统对内存屏障的支持</strong></p> <p>gcc 编译器在遇到内嵌汇编语句 <code class="language-plaintext highlighter-rouge">asm volatile(“” ::: “memory”)</code>，将以此作为一条内存屏障，重排序内存操作，即此语句之前的各种编译优化将不会持续到此语句之后。</p> <p>Linux 内核提供函数 <code class="language-plaintext highlighter-rouge">barrier()</code> 用于让编译器保证其之前的内存访问先于其之后的完成。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#define barrier() __asm__ __volatile__("" ::: "memory")
</span></code></pre></div></div> <p>CPU内存屏障：</p> <ul> <li>通用 barrier，保证读写操作有序， <code class="language-plaintext highlighter-rouge">mb()</code> 和 <code class="language-plaintext highlighter-rouge">smp_mb()</code></li> <li>写操作 barrier，仅保证写操作有序，<code class="language-plaintext highlighter-rouge">wmb()</code> 和 <code class="language-plaintext highlighter-rouge">smp_wmb()</code></li> <li>读操作 barrier，仅保证读操作有序，<code class="language-plaintext highlighter-rouge">rmb()</code> 和 <code class="language-plaintext highlighter-rouge">smp_rmb()</code></li> </ul> <p><strong>小结</strong></p> <ul> <li>为了提高处理器的性能，SMP 中引入了 store buffer (以及对应实现store buffer forwarding) 和 invalidate queue。</li> <li>store buffer 的引入导致 core 上的 store 顺序可能不匹配于 global memory 的顺序，对此，我们需要使用 <code class="language-plaintext highlighter-rouge">wmb()</code> 来解决。</li> <li>invalidate queue 的存在导致 core 上观察到的 load 顺序可能与 global memory order 不一致，对此，我们需要使用 <code class="language-plaintext highlighter-rouge">rmb()</code> 来解决。</li> <li>由于 <code class="language-plaintext highlighter-rouge">wmb()</code> 和 <code class="language-plaintext highlighter-rouge">rmb()</code> 分别只单独作用于 store buffer 和 invalidate queue，因此这两个 memory barrier 共同保证了 store/load 的顺序。</li> </ul> <h2 id="伪共享">伪共享</h2> <p>多个线程同时读写同一个 Cache Line 中的变量、导致 CPU Cache 频繁失效，从而使得程序性能下降的现象称为伪共享（False Sharing）。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">shm_size</span> <span class="o">=</span> <span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span> <span class="c1">//16M</span>
  <span class="k">static</span> <span class="kt">char</span> <span class="n">shm</span><span class="p">[</span><span class="n">shm_size</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">shm_offset</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

  <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
          <span class="k">auto</span> <span class="n">off</span> <span class="o">=</span> <span class="n">shm_offset</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="n">shm_size</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
          <span class="o">*</span><span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)(</span><span class="n">shm</span> <span class="o">+</span> <span class="n">off</span><span class="p">)</span> <span class="o">=</span> <span class="n">off</span><span class="p">;</span> <span class="c1">// 赋值</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div> <p>考察上面的程序：<code class="language-plaintext highlighter-rouge">shm</code> 是一块 16M 字节的内存，我测试的机器的 L3 Cache 是 32M，16M 字节能确保 <code class="language-plaintext highlighter-rouge">shm</code> 在 Cache 里放得下。<code class="language-plaintext highlighter-rouge">f()</code> 函数的循环里，视 <code class="language-plaintext highlighter-rouge">shm</code> 为 <code class="language-plaintext highlighter-rouge">long</code> 类型的数组，依次给每个元素赋值，<code class="language-plaintext highlighter-rouge">shm_offset</code> 用于记录偏移位置，<code class="language-plaintext highlighter-rouge">shm_offset.fetch_add(sizeof(long))</code> 原子性的增加 <code class="language-plaintext highlighter-rouge">shm_offset</code> 的值（因为x86_64系统上 <code class="language-plaintext highlighter-rouge">long</code> 的长度为8，所以 <code class="language-plaintext highlighter-rouge">shm_offset</code> 每次增加8），并返回增加前的值，对 <code class="language-plaintext highlighter-rouge">shm</code> 上 <code class="language-plaintext highlighter-rouge">long</code> 数组的每个元素赋值后，结束循环从函数返回。</p> <p>因为 <code class="language-plaintext highlighter-rouge">shm_offset</code> 是 <code class="language-plaintext highlighter-rouge">atomic</code> 类型变量，所以多线程调用 <code class="language-plaintext highlighter-rouge">f()</code> 依然能正常工作，虽然多个线程会竞争 <code class="language-plaintext highlighter-rouge">shm_offset</code>，但每个线程会排他性的对各 <code class="language-plaintext highlighter-rouge">long</code> 元素赋值，多线程并行会加快对 <code class="language-plaintext highlighter-rouge">shm</code> 的赋值操作。我们加上多线程调用代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">step</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

  <span class="k">const</span> <span class="kt">int</span> <span class="n">THREAD_NUM</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">work_thread</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">int</span> <span class="n">LOOP_N</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">LOOP_N</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">f</span><span class="p">();</span>
          <span class="o">++</span><span class="n">step</span><span class="p">;</span>
          <span class="k">while</span> <span class="p">(</span><span class="n">step</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">THREAD_NUM</span><span class="p">)</span> <span class="p">{}</span>
          <span class="n">shm_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threads</span><span class="p">[</span><span class="n">THREAD_NUM</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">work_thread</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">main</code> 函数里启动2个工作线程 <code class="language-plaintext highlighter-rouge">work_thread</code>。 工作线程对 <code class="language-plaintext highlighter-rouge">shm</code> 共计赋值10轮，后面的每一轮会访问 Cache 里的 <code class="language-plaintext highlighter-rouge">shm</code> 数据，<code class="language-plaintext highlighter-rouge">step</code> 用于 <code class="language-plaintext highlighter-rouge">work_thread</code> 之间每一轮的同步。 工作线程调用完 <code class="language-plaintext highlighter-rouge">f()</code> 后会增加 <code class="language-plaintext highlighter-rouge">step</code>，等2个工作线程都调用完之后，<code class="language-plaintext highlighter-rouge">step</code> 的值增加到 <code class="language-plaintext highlighter-rouge">n * THREAD_NUM</code> 后，<code class="language-plaintext highlighter-rouge">while()</code> 会结束循环，重置 <code class="language-plaintext highlighter-rouge">shm_offset</code>，重新开始新一轮对 <code class="language-plaintext highlighter-rouge">shm</code> 的赋值。</p> <p>如图所示：</p> <center> <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://p0.meituan.net/travelcube/a74220a3c91fffad017e1ca8b3b02d28157434.png" /> </center> <p>编译后执行上面的程序，产生如下的结果：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">time</span> ./a.out

  real 0m3.406s
  user 0m6.740s
  sys 0m0.040s
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">time</code> 命令用于时间测量，<code class="language-plaintext highlighter-rouge">a.out</code> 程序运行完成后会打印耗时，<code class="language-plaintext highlighter-rouge">real</code> 列显式耗时3.4秒。</p> <h3 id="1-改进版-f_fast">1. 改进版 f_fast</h3> <p>我们稍微修改一下 <code class="language-plaintext highlighter-rouge">f</code> 函数，改进版 <code class="language-plaintext highlighter-rouge">f</code> 函数取名 <code class="language-plaintext highlighter-rouge">f_fast</code>：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">f_fast</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
          <span class="k">const</span> <span class="kt">long</span> <span class="n">inner_loop</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
          <span class="k">auto</span> <span class="n">off</span> <span class="o">=</span> <span class="n">shm_offset</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="o">*</span> <span class="n">inner_loop</span><span class="p">);</span>
          <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">inner_loop</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="n">shm_size</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
              <span class="o">*</span><span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)(</span><span class="n">shm</span> <span class="o">+</span> <span class="n">off</span><span class="p">)</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
              <span class="n">off</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">for</code> 循环里，<code class="language-plaintext highlighter-rouge">shm_offset</code> 不再是每次增加8字节（<code class="language-plaintext highlighter-rouge">sizeof(long)</code>），而是 8*16=128 字节，然后在内层的循环里，依次对16个 <code class="language-plaintext highlighter-rouge">long</code> 连续元素赋值，然后下一轮循环又再次增加128字节，直到完成对 <code class="language-plaintext highlighter-rouge">shm</code> 的赋值。如图所示：</p> <center> <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://p0.meituan.net/travelcube/3a6d828073f5cd09877a906edbb5e8c3240113.png" /> </center> <p>编译后重新执行程序，结果显示耗时降低到0.06秒，对比前一种耗时3.4秒，<code class="language-plaintext highlighter-rouge">f_fast</code> 性能提升明显。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">time</span> ./a.out

  real 0m0.062s
  user 0m0.110s
  sys 0m0.012s
</code></pre></div></div> <p><strong><code class="language-plaintext highlighter-rouge">f </code>和 <code class="language-plaintext highlighter-rouge">f_fast</code> 的行为差异</strong></p> <p><code class="language-plaintext highlighter-rouge">shm</code> 数组总共有 2M 个 <code class="language-plaintext highlighter-rouge">long</code> 元素，因为 <code class="language-plaintext highlighter-rouge">16M / sizeof(long)</code> 得 2M：</p> <p>1、<code class="language-plaintext highlighter-rouge">f()</code> 函数行为逻辑</p> <ul> <li>线程1和线程2的 <code class="language-plaintext highlighter-rouge">work_thread</code> 里会交错地对 <code class="language-plaintext highlighter-rouge">shm</code> <code class="language-plaintext highlighter-rouge">元素赋值，shm</code> 的 2M 个 <code class="language-plaintext highlighter-rouge">long</code> 元素，会顺序的一个接一个的派给2个线程去赋值。</li> <li>可能的行为：元素1由线程1赋值，元素2由线程2赋值，然后元素3和元素4由线程1赋值，然后元素5又由线程2赋值…</li> <li>每次分派元素的时候，<code class="language-plaintext highlighter-rouge">shm_offset</code> 都会 <code class="language-plaintext highlighter-rouge">atomic</code> 的增加8字节，所以不会出现2个线程给同1个元素赋值的情况。</li> </ul> <p>2、f_fast() 函数行为逻辑</p> <ul> <li>每次派元素的时候，<code class="language-plaintext highlighter-rouge">shm_offset</code> 原子性的增加128字节（16个元素）。</li> <li>这16个字节作为一个整体，派给线程1或者线程2；虽然线程1和线程2还是会交错的操作 <code class="language-plaintext highlighter-rouge">shm</code> 元素，但是以16个元素（128字节）为单元，这16个连续的元素不会被分开派发给不同线程。</li> <li>一次派发的16个元素，会在一个线程里被一个接着一个的赋值（内部循环里）。</li> </ul> <h3 id="2-为什么-f_fast-更快">2 为什么 f_fast 更快</h3> <p>第一眼感觉是 <code class="language-plaintext highlighter-rouge">f_fast()</code> 里 <code class="language-plaintext highlighter-rouge">shm_offset.fetch_add()</code> 调用频次降低到了原来的 1/16，有理由怀疑是原子变量的竞争减少导致程序执行速度加快。为了验证，让我们在内层的循环里加一个原子变量 <code class="language-plaintext highlighter-rouge">test</code> 的 <code class="language-plaintext highlighter-rouge">fetch_add</code>，<code class="language-plaintext highlighter-rouge">test</code> 原子变量的竞争会像 <code class="language-plaintext highlighter-rouge">f()</code> 函数里 <code class="language-plaintext highlighter-rouge">shm_offset.fetch_add()</code> 一样激烈，修改后的 <code class="language-plaintext highlighter-rouge">f_fast</code> 代码变成下面这样：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">f_fast</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
          <span class="k">const</span> <span class="kt">long</span> <span class="n">inner_loop</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
          <span class="k">auto</span> <span class="n">off</span> <span class="o">=</span> <span class="n">shm_offset</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="o">*</span> <span class="n">inner_loop</span><span class="p">);</span>
          <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">inner_loop</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">test</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="n">shm_size</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
              <span class="o">*</span><span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)(</span><span class="n">shm</span> <span class="o">+</span> <span class="n">off</span><span class="p">)</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
              <span class="n">off</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div> <p>为了避免 <code class="language-plaintext highlighter-rouge">test.fetch_add(1)</code> 的调用被编译器优化掉，我们在 <code class="language-plaintext highlighter-rouge">main</code> 函数的最后把 <code class="language-plaintext highlighter-rouge">test</code> 的值打印出来。编译后测试一下，结果显示：执行时间只是稍微增加到 <code class="language-plaintext highlighter-rouge">real 0m0.326s</code>，很显然，并不是 <code class="language-plaintext highlighter-rouge">atomic</code> 的调用频次减少导致性能飙升。</p> <p>重新审视 <code class="language-plaintext highlighter-rouge">f()</code> 循环里的逻辑：<code class="language-plaintext highlighter-rouge">f()</code> 循环里的操作很简单：原子增加、判断、赋值。我们把 <code class="language-plaintext highlighter-rouge">f()</code> 的里赋值注释掉，再测试一下，发现它的速度得到了很大提升，看来是 <code class="language-plaintext highlighter-rouge">(long)(shm + off) = off</code> 这一行代码执行慢，但这明明只是一行赋值。我们把它反汇编来看，它只是一个 <code class="language-plaintext highlighter-rouge">mov</code> 指令，源操作数是寄存器，目标操作数是内存地址，从寄存器拷贝数据到一个内存地址，为什么会这么慢呢？</p> <h3 id="3-原因">3 原因</h3> <p>现在揭晓答案：导致 <code class="language-plaintext highlighter-rouge">f()</code> 性能底下的元凶是伪共享（false sharing）。那什么是伪共享？要说清这个问题，还得联系 CPU 的架构以及 CPU 怎么访问数据，回顾一下关于多核 Cache 结构。</p> <p><strong>背景知识</strong></p> <p>现代 CPU 可以有多个核，每个核有自己的 L1-L2 缓存，L1又区分数据缓存（L1-DCache）和指令缓存（L1-ICache），L2 不区分数据和指令 Cache，而 L3 是跨核共享的，L3 通过内存总线连接到内存，内存被所有 CPU 所有 Core 共享。</p> <p>CPU 访问 L1 Cache 的速度大约是访问内存的100倍，Cache 作为 CPU 与内存之间的缓存，减少对内存的访问频率。</p> <p>从内存加载数据到 Cache 的时候，是以 Cache Line 为长度单位的，Cache Line 的长度通常是64字节，所以，那怕只读一个字节，但是包含该字节的整个 Cache Line 都会被加载到缓存，同样，如果修改一个字节，那么最终也会导致整个 Cache Line 被冲刷到内存。</p> <p>如果一块内存数据被多个线程访问，假设多个线程在多个 Core 上并行执行，那么它便会被加载到多个 Core 的的 Local Cache 中；这些线程在哪个 Core 上运行，就会被加载到哪个 Core 的 Local Cache 中，所以，内存中的一个数据，在不同 Core 的 Cache 里会同时存在多份拷贝。</p> <p>那么，便会存在缓存一致性问题。当一个 Core 修改其缓存中的值时，其他 Core 不能再使用旧值。该内存位置将在所有缓存中失效。此外，由于缓存以缓存行而不是单个字节的粒度运行，因此整个缓存行将在所有缓存中失效。如果我们修改了 Core1 缓存里的某个数据，则该数据所在的 Cache Line 的状态需要同步给其他 Core 的缓存，Core 之间可以通过核间消息同步状态，比如通过发送 Invalidate 消息给其他核，接收到该消息的核会把对应 Cache Line 置为无效，然后重新从内存里加载最新数据。</p> <p>当然，被加载到多个 Core 缓存中的同一 Cache Line，会被标记为共享（Shared）状态，对共享状态的缓存行进行修改，需要先获取缓存行的修改权（独占），MESI 协议用来保证多核缓存的一致性，更多的细节可以参考 MESI 的文章。</p> <p><strong>示例分析</strong></p> <p>假设线程1运行在 Core1，线程2运行在 Core2。</p> <ul> <li>因为 <code class="language-plaintext highlighter-rouge">shm</code> 被线程1和线程2这两个线程并发访问，所以 <code class="language-plaintext highlighter-rouge">shm</code> 的内存数据会以 Cache Line 粒度，被同时加载到2个 Core 的 Cache，因为被多核共享，所以该 Cache Line 被标注为 Shared 状态。</li> <li>假设线程1在 <code class="language-plaintext highlighter-rouge">offset</code> 为64的位置写入了一个8字节的数据（<code class="language-plaintext highlighter-rouge">sizeof(long)</code>），要修改一个状态为 Shared 的 Cache Line，Core1 会发送核间通信消息到 Core2，去拿到该Cache Line的独占权，在这之后，Core1 才能修改 Local Cache</li> <li>线程1执行完 <code class="language-plaintext highlighter-rouge">shm_offset.fetch_add(sizeof(long))</code> <code class="language-plaintext highlighter-rouge">后，shm_offset</code> 会增加到72。</li> <li>这时候 Core2 上运行的线程2也会执行 <code class="language-plaintext highlighter-rouge">shm_offset.fetch_add(sizeof(long))</code>，它返回72并将 <code class="language-plaintext highlighter-rouge">shm_offset</code> 增加到80。</li> <li>线程2接下来要修改 <code class="language-plaintext highlighter-rouge">shm[72]</code> 的内存位置，因为 <code class="language-plaintext highlighter-rouge">shm[64]</code> 和 <code class="language-plaintext highlighter-rouge">shm[72]</code> 在一个 Cache Line，而这个 Cache Line 又被置为 Invalidate，所以，它需要从内存里重新加载这一个 Cache Line，而在这之前，Core1 上的线程1需要把 Cache Line 冲刷到内存，这样线程2才能加载最新的数据。</li> </ul> <p>这种交替执行模式，相当于 Core1 和 Core2 之间需要频繁的发送核间消息，收到消息的 Core 的 Cache Line 被置为无效，并重新从内存里加载数据到 Cache，每次修改后都需要把 Cache 中的数据刷入内存，这相当于废弃掉了 Cache，因为每次读写都直接跟内存打交道，Cache 的作用不复存在，这就是性能低下的原因。</p> <p>这种多核多线程程序，因为并发读写同一个 Cache Line 的数据（临近位置的内存数据），导致 Cache Line 的频繁失效，内存的频繁 Load/Store，从而导致性能急剧下降的现象叫伪共享，伪共享是性能杀手。</p> <h3 id="4-另一个伪共享的例子">4 另一个伪共享的例子</h3> <p>假设线程 x 和 y，分别修改 Data 的 a 和 b 变量，如果被频繁调用，也会出现性能低下的情况，怎么规避呢？</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">struct</span> <span class="nc">Data</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// global</span>

  <span class="kt">void</span> <span class="n">thread1</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">thread2</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div> <p><strong>空间换时间</strong></p> <p>避免 Cache 伪共享导致性能下降的思路是用空间换时间，通过增加填充，让 a 和 b 两个变量分布到不同的 Cache Line，这样对 a 和 b 的修改就会作用于不同 Cache Line，就能避免 Cache 失效的问题。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">struct</span> <span class="nc">Data</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">padding</span><span class="p">[</span><span class="mi">60</span><span class="p">];</span>
      <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">};</span>
</code></pre></div></div> <p>在 Linux kernel 中存在 <code class="language-plaintext highlighter-rouge">__cacheline_aligned_in_smp</code> 宏定义用于解决 false sharing 问题。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#ifdef CONFIG_SMP
</span>  <span class="cp">#define __cacheline_aligned_in_smp __cacheline_aligned
</span>  <span class="cp">#else
</span>  <span class="cp">#define __cacheline_aligned_in_smp
</span>  <span class="cp">#endif
</span>
  <span class="k">struct</span> <span class="nc">Data</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">b</span> <span class="n">__cacheline_aligned_in_smp</span><span class="p">;</span>
  <span class="p">};</span>
</code></pre></div></div> <p>从上面的宏定义，可以看到：</p> <ul> <li>在多核系统里，该宏定义是 <code class="language-plaintext highlighter-rouge">__cacheline_aligned</code>，也就是 Cache Line 的大小</li> <li>在单核系统里，该宏定义是空的</li> </ul> <h2 id="总结">总结</h2> <p><code class="language-plaintext highlighter-rouge">pthread</code> 接口提供的几种同步原语如下：</p> <center> <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://p0.meituan.net/travelcube/9b8c086ae944f0d4861f9b398c673c0e349572.png" /> </center> <p>由于 Linux 下线程和进程本质都是 LWP，那么进程间通信使用的 IPC（管道、FIFO、消息队列、信号量）线程间也可以使用，也可以达到相同的作用。 但是由于 IPC 资源在进程退出时不会清理（因为它是系统资源），因此不建议使用。</p> <p>以下是一些非锁但是也能实现线程安全或者部分线程安全的常见做法：</p> <center> <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://p0.meituan.net/travelcube/43010f87d03c76ab29d444f3469875ac380936.png" /> </center> <p>可以看到，上面很多做法都是采用了副本，尽量避免在 thread 中间共享数据。最快的同步就是没同步（The fastest synchronization of all is the kind that never takes place），Share nothing is best。</p> <p><br /></p> <script> window.onresize = () => ce(); window.onload = () => ce(); const ce = () => { let docWidth = document.documentElement.clientWidth; document.querySelectorAll("[img-w]")?.forEach(cw(docWidth)); }; const ckw = (dw,o) => dw >= 750 ? o.getAttribute('img-w') + '%' : '100%'; const cw = w => o => o.setAttribute('width', ckw(w,o)); </script> <div class="post-tags"> <nav class="nav-post-tags-list"> <ul class="tags"> <li><a href="/tag/multithreading/">Multithreading</a></li> <li><a href="/tag/c/">C++</a></li> <li><a href="/tag/liunx/">Liunx</a></li> </ul> </nav> </div> </main> <footer> <hr class="footer-hr"> <div class="ui-flex"> <div class='wrapper-footer'> © 2025 Out of Memory.blog | <a href="mailto:yvens.fv@gmail.com">yvens</a> </div> </div> </footer> </div> </body> </html>
