<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="shortcut icon" href="/favicon.ico"> <title>[JAVA] Java 并发之 volatile 的实现原理 - Out of Memory .blog</title> <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet"> <link rel="stylesheet" href="/assets/dist/css/style.css"> <!-- <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_big-stone.min.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_white.min.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-base16.dark.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-github.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> --> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>[JAVA] Java 并发之 volatile 的实现原理 | Out of Memory</title> <meta name="generator" content="Jekyll v3.9.2" /> <meta property="og:title" content="[JAVA] Java 并发之 volatile 的实现原理" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="在多线程并发编程中，volatile 保证了共享变量的“可见性”。可见性的意思是当一个线程修改了一个共享变量时，另一个线程能及时读到这个修改的值。当然 synchronized 也能达到相同的效果，但在恰当的使用 volatile 修饰变量的情况，是比 synchronized 效率更高的，因为它不会引起线程上下文的切换和调度。" /> <meta property="og:description" content="在多线程并发编程中，volatile 保证了共享变量的“可见性”。可见性的意思是当一个线程修改了一个共享变量时，另一个线程能及时读到这个修改的值。当然 synchronized 也能达到相同的效果，但在恰当的使用 volatile 修饰变量的情况，是比 synchronized 效率更高的，因为它不会引起线程上下文的切换和调度。" /> <link rel="canonical" href="https://outofmemory.blog/java-concurrency-volatile.html" /> <meta property="og:url" content="https://outofmemory.blog/java-concurrency-volatile.html" /> <meta property="og:site_name" content="Out of Memory" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2020-03-10T00:00:00+08:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="[JAVA] Java 并发之 volatile 的实现原理" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2020-03-10T00:00:00+08:00","datePublished":"2020-03-10T00:00:00+08:00","description":"在多线程并发编程中，volatile 保证了共享变量的“可见性”。可见性的意思是当一个线程修改了一个共享变量时，另一个线程能及时读到这个修改的值。当然 synchronized 也能达到相同的效果，但在恰当的使用 volatile 修饰变量的情况，是比 synchronized 效率更高的，因为它不会引起线程上下文的切换和调度。","headline":"[JAVA] Java 并发之 volatile 的实现原理","mainEntityOfPage":{"@type":"WebPage","@id":"https://outofmemory.blog/java-concurrency-volatile.html"},"url":"https://outofmemory.blog/java-concurrency-volatile.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="content"> <header> <div class="main"> <a href="https://outofmemory.blog/">Out of Memory</a>.blog </div> <nav> <a class='' href="/">首页</a> <!-- <a class='' href="/archives.html"> Archives</a> --> <a class='' href="/about.html">关于</a> </nav> </header> <hr class="light-hr"> <main> <div class="title"> <h1 class="title">[JAVA] Java 并发之 volatile 的实现原理</h1> <div class="meta"> <time datetime="10-03-2020">Mar 10 2020</time> </div> </div> <hr class="no-margin light-hr "> <p>在多线程并发编程中，volatile 保证了共享变量的“可见性”。可见性的意思是当一个线程修改了一个共享变量时，另一个线程能及时读到这个修改的值。当然 synchronized 也能达到相同的效果，但在恰当的使用 volatile 修饰变量的情况，是比 synchronized 效率更高的，因为它不会引起线程上下文的切换和调度。</p> <h2 id="volatile-的定义">volatile 的定义</h2> <p>Java语言规范一文中对 volatile 的定义如下：</p> <blockquote> <p>Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了 volatile，在某些情况下比锁要更加方便。如果一个字段被声明成 volatile，Java线程内存模型确保所有线程看到这个变量的值时一致的。</p> </blockquote> <h2 id="volatile-的实现原理">volatile 的实现原理</h2> <p>在了解它的实现原理之前，我们需要先了解一下与其实现原理相关的CPU术语：</p> <table> <thead> <tr> <th>术 语</th> <th>英 文</th> <th>描 述</th> </tr> </thead> <tbody> <tr> <td>内存屏障</td> <td>memory barriers</td> <td>一组处理器指令，用于实现对内存操作的顺序限制</td> </tr> <tr> <td>缓存行</td> <td>cache line</td> <td>CPU高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行，现代CPU需要执行几百次CPU指令</td> </tr> <tr> <td>原子操作</td> <td>atomic operations</td> <td>不可中断的一个或一系列操作</td> </tr> <tr> <td>缓存行填充</td> <td>cache line fill</td> <td>当CPU识别到从内存中读取操作数是可缓存的，CPU读取整个高速缓存行到适当的缓存区域(L1、L2、L3或所有)</td> </tr> <tr> <td>缓存命中</td> <td>cache hit</td> <td>如果进行高速缓存行填充操作的内存位置仍然是下次CPU访问的地址时，CPU从缓存中读取操作数，而不是从内存中读取</td> </tr> <tr> <td>         <br />写命中          </td> <td>                <br />write hit                    </td> <td>当CPU将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则CPU将这个操作数写回到缓存，而不是写回到内存</td> </tr> <tr> <td>写缺失</td> <td>write misses the cache</td> <td>一个有效的缓存行被写入到不存在的内存区域</td> </tr> </tbody> </table> <p>volatile 具体是怎么保证可见性的，看看修改 volatile 变量时 JIT 编译器生成的汇编代码(编译处理器为 Intel Core i7，x86-64 指令集)：</p> <p>Java 代码：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="c1">// 普通变量</span>
    <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// volatile 修饰的变量</span>
    <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">volSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Main</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 为了得到汇编代码循环100000次</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">volSum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Main</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>生成的汇编代码：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># {method} {0x0000000129168270} '&lt;init&gt;' '()V' in 'com/demo/Main'
#           [sp+0x60]  (sp of caller)
...
0x00000001111218a7: add %rax,%rbx
0x00000001111218aa: mov %rbx,0x10(%rsi)  ;*putfield sum
                                         ; - com.demo.Main::&lt;init&gt;@30 (line 11)
...
0x00000001111218b8: add %rax,%rbx
0x00000001111218bb: mov %rbx,0x40(%rsp)
0x00000001111218c0: vmovsd 0x40(%rsp),%xmm0
0x00000001111218c6: vmovsd %xmm0,0x18(%rsi)
0x00000001111218cb: lock addl $0x0,(%rsp)  ;*putfield volSum
                                           ; - com.demo.Main::&lt;init&gt;@41 (line 12)
...
</code></pre></div></div> <p>通过对比可以发现，有 volatile 修饰的变量进行写操作的时候会多出 lock 前缀指令的汇编代码，而 lock 前缀指令在多核处理器下会触发两件事：</p> <ol> <li>将这个处理器缓存行的数据写回到系统内存。</li> <li>这个写回内存的操作会使其他 CPU 里缓存了该内存地址的数据无效。</li> </ol> <p>为了提高处理速度，处理器不直接和内存进行通行，而是先将系统内存的数据读取到内部缓存（L1、L2或其他）后再进行操作，但操作完不知道何时会写回到内存。如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作时，就会重新从系统内存中把数据读取到处理器缓存中。</p> <p>volatile 具体的两条实现原则：</p> <ol> <li><strong>Lock 前缀指令会触发处理器缓存写回到内存。</strong><br /> Lock 前缀指令导致在执行指令期间，声言处理器的 <code class="language-plaintext highlighter-rouge">LOCK#</code> 信号。在多处理器环境中，<code class="language-plaintext highlighter-rouge">LOCK#</code> 信号确保在声言改信号期间，处理器可以独占任何共享内存(因为它会锁住总线，导致其他处理器不能访问总线，不能访问总线就意味着不能访问系统内存)。但是，在最近的处理器里，<code class="language-plaintext highlighter-rouge">LOCK#</code> 信号一般不锁总线，而是锁缓存，毕竟锁总线的开销比较大。对于 Intel486 和 Pentium 处理器，在锁操作时，总是在总线上声言 <code class="language-plaintext highlighter-rouge">LOCK#</code> 信号。但是在 P6 和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言 <code class="language-plaintext highlighter-rouge">LOCK#</code> 信号。相反，它会锁定这块内存区域的缓存并写回到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。<br /><br /></li> <li><strong>一个处理器的缓存写回到内存会导致其他处理器的缓存无效。</strong><br /> IA-32 处理器和 Intel 64 处理器使用 MESI (修改、独占、共享、无效)控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32 和 Intel 64 处理器能嗅探其他处理器访问系统内存和它们的内部缓存。处理器使用嗅探技术确保它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保存一致。例如 Pentium 和 P6 family 处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。</li> </ol> <p><br /></p> <div class="post-tags"> <nav class="nav-post-tags-list"> <ul class="tags"> <li><a href="/tag/java/">Java</a></li> <li><a href="/tag/concurrency/">Concurrency</a></li> <li><a href="/tag/volatile/">volatile</a></li> </ul> </nav> </div> </main> <footer> <hr class="footer-hr"> <div class="ui-flex"> <div class='wrapper-footer'> © 2023 Out of Memory.blog | <a href="mailto:dr.xx.yvens@gmail.com">Yven Fong</a> </div> </div> </footer> </div> </body> </html>
