<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="shortcut icon" href="/favicon.ico"> <title>[JAVA] Java 并发之 volatile 的实现原理 - Out of Memory</title> <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet"> <link rel="stylesheet" href="/assets/dist/css/style.css"> <!-- <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_big-stone.min.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_white.min.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-base16.dark.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-github.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> --> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>[JAVA] Java 并发之 volatile 的实现原理 | Out of Memory</title> <meta name="generator" content="Jekyll v3.9.2" /> <meta property="og:title" content="[JAVA] Java 并发之 volatile 的实现原理" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="在多线程并发编程中，volatile 保证了共享变量的可见性。可见性的意思是当一个线程修改了一个共享变量时，另一个线程能及时读到这个修改的值。当然 synchronized 也能达到相同的效果，但在恰当的使用 volatile 修饰变量的情况，是比 synchronized 效率更高的，因为它不会引起线程上下文的切换和调度。" /> <meta property="og:description" content="在多线程并发编程中，volatile 保证了共享变量的可见性。可见性的意思是当一个线程修改了一个共享变量时，另一个线程能及时读到这个修改的值。当然 synchronized 也能达到相同的效果，但在恰当的使用 volatile 修饰变量的情况，是比 synchronized 效率更高的，因为它不会引起线程上下文的切换和调度。" /> <link rel="canonical" href="https://outofmemory.blog/java-concurrency-volatile.html" /> <meta property="og:url" content="https://outofmemory.blog/java-concurrency-volatile.html" /> <meta property="og:site_name" content="Out of Memory" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2020-03-10T00:00:00+08:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="[JAVA] Java 并发之 volatile 的实现原理" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2020-03-10T00:00:00+08:00","datePublished":"2020-03-10T00:00:00+08:00","description":"在多线程并发编程中，volatile 保证了共享变量的可见性。可见性的意思是当一个线程修改了一个共享变量时，另一个线程能及时读到这个修改的值。当然 synchronized 也能达到相同的效果，但在恰当的使用 volatile 修饰变量的情况，是比 synchronized 效率更高的，因为它不会引起线程上下文的切换和调度。","headline":"[JAVA] Java 并发之 volatile 的实现原理","mainEntityOfPage":{"@type":"WebPage","@id":"https://outofmemory.blog/java-concurrency-volatile.html"},"url":"https://outofmemory.blog/java-concurrency-volatile.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="content"> <header> <div class="main"> <a href="https://outofmemory.blog/">Out of Memory</a> </div> <nav> <a class='' href="/">首页</a> <!-- <a class='' href="/archives.html"> Archives</a> --> <a class='' href="/about.html">关于</a> </nav> </header> <hr class="light-hr"> <main> <div class="title"> <h1 class="title">[JAVA] Java 并发之 volatile 的实现原理</h1> <div class="meta"> <time datetime="10-03-2020">Mar 10 2020</time> </div> </div> <hr class="no-margin light-hr "> <p>在多线程并发编程中，<code class="language-plaintext highlighter-rouge">volatile</code> 保证了共享变量的<strong>可见性</strong>。可见性的意思是当一个线程修改了一个共享变量时，另一个线程能及时读到这个修改的值。当然 <code class="language-plaintext highlighter-rouge">synchronized</code> 也能达到相同的效果，但在恰当的使用 <code class="language-plaintext highlighter-rouge">volatile</code> 修饰变量的情况，是比 <code class="language-plaintext highlighter-rouge">synchronized</code> 效率更高的，因为它不会引起线程上下文的切换和调度。</p> <h2 id="volatile-的定义">volatile 的定义</h2> <p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.4" target="_blank">Java 语言规范 8.3.1.4</a> 一节中对 <code class="language-plaintext highlighter-rouge">volatile</code> 的定义如下：</p> <blockquote> <p>Java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java 语言提供了 <code class="language-plaintext highlighter-rouge">volatile</code>，在某些情况下比锁要更加方便。如果一个字段被声明成 <code class="language-plaintext highlighter-rouge">volatile</code>，Java 线程内存模型确保所有线程看到这个变量的值时一致的。</p> </blockquote> <h2 id="volatile-的实现原理">volatile 的实现原理</h2> <p><code class="language-plaintext highlighter-rouge">volatile</code> 具体是怎么保证可见性的，先通过一个例子来分析。这段简单的代码是修改 <code class="language-plaintext highlighter-rouge">volatile</code> 修饰的变量然后生成汇编代码(编译处理器为 Intel Core i7，x86-64 指令集)：</p> <p>Java 代码：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="c1">// 普通变量</span>
    <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// volatile 修饰的变量</span>
    <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">volSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Main</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 为了得到汇编代码循环100000次 =。=</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">volSum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Main</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>生成的汇编代码：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># {method} {0x0000000129168270} '&lt;init&gt;' '()V' in 'org/demo/Main'
#           [sp+0x60]  (sp of caller)
...
0x00000001111218a7: add %rax,%rbx
0x00000001111218aa: mov %rbx,0x10(%rsi)  ;*putfield sum
                                         ; - org.demo.Main::&lt;init&gt;@30 (line 11)
...
0x00000001111218b8: add %rax,%rbx
0x00000001111218bb: mov %rbx,0x40(%rsp)
0x00000001111218c0: vmovsd 0x40(%rsp),%xmm0
0x00000001111218c6: vmovsd %xmm0,0x18(%rsi)
0x00000001111218cb: lock addl $0x0,(%rsp)  ;*putfield volSum
                                           ; - org.demo.Main::&lt;init&gt;@41 (line 12)
...
</code></pre></div></div> <p>通过对比可以发现，有 <code class="language-plaintext highlighter-rouge">volatile</code> 修饰的变量进行写操作的时候会多出 <code class="language-plaintext highlighter-rouge">lock addl</code> 前缀指令的汇编代码。查询 <a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html" target="_blank">IA32 手册</a>可知，<code class="language-plaintext highlighter-rouge">addl</code> 指令是一个空操作，而 <code class="language-plaintext highlighter-rouge">lock</code> 的作用是将本处理器的缓存写回内存，相当于一个<strong>内存屏障 (Memory Barrier)</strong>。</p> <p>由于处理器和内存之间的运算速度有几个数量级的差距，为了提高处理速度，处理器不直接和内存进行通行，而是先将内存的数据读取到内部高速缓存（L1、L2或其他）后再进行操作。在多处理器下，每个处理器都有自己的高速缓存，然后又共享一个主内存，所以当多个处理器的操作涉及到了主内存的同一块区域，就可能导致各自的缓存数据不一致(过期)。为了解决这个<strong>缓存一致性 (Cache Coherence)</strong> 问题，就要求各个处理器根据一些协议（如 MESI、MOSI、MSI、Firefly 等）来进行读写：每个处理器通过嗅探在总线上传播的数据来检查自己的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态；当处理器对这个数据进行修改操作时，就会重新从主内存中把数据读取到处理器缓存中。</p> <p>所以对 <code class="language-plaintext highlighter-rouge">volatile</code> 修饰的变量进行写操作，JVM 就会向处理器发送一条 <code class="language-plaintext highlighter-rouge">lock</code> 前缀指令，将这个变量所在缓存行的数据写回到系统内存，然后通过缓存一致性协议，保证多核处理器下的各核数据一致。</p> <p>不过值得注意的一点是， <strong><code class="language-plaintext highlighter-rouge">volatile</code> 只是保证了变量的可见性，并不保证操作的原子性</strong>。在一些操作下仍需要通过加锁来保证原子性，比如单例模式一种常见的线程安全实现方式，双重验证 (Double Check Lock)：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="no">INSTANCE</span><span class="o">){</span>
            <span class="kd">synchronized</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="no">INSTANCE</span><span class="o">)</span> <span class="o">{</span>
                    <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Singleton.getInstance();</span>
<span class="o">}</span>
</code></pre></div></div> <p><br /></p> <div class="post-tags"> <nav class="nav-post-tags-list"> <ul class="tags"> <li><a href="/tag/java/">Java</a></li> <li><a href="/tag/concurrency/">Concurrency</a></li> <li><a href="/tag/volatile/">volatile</a></li> </ul> </nav> </div> </main> <footer> <hr class="footer-hr"> <div class="ui-flex"> <div class='wrapper-footer'> © 2023 Out of Memory.blog | <a href="mailto:yvens.fv@gmail.com">Yven Fong</a> </div> </div> </footer> </div> </body> </html>
