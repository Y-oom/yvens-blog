<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="shortcut icon" href="/favicon.ico"> <title>[Java] java.lang.OutOfMemoryError - Out of Memory</title> <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet"> <link rel="stylesheet" href="/assets/dist/css/style.css"> <!-- <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_big-stone.min.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_white.min.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-base16.dark.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-github.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> --> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>[Java] java.lang.OutOfMemoryError | Out of Memory</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="[Java] java.lang.OutOfMemoryError" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="INDEX" /> <meta property="og:description" content="INDEX" /> <link rel="canonical" href="https://outofmemory.blog/outofmemoryerror-p1.html" /> <meta property="og:url" content="https://outofmemory.blog/outofmemoryerror-p1.html" /> <meta property="og:site_name" content="Out of Memory" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2018-03-08T00:00:00+08:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="[Java] java.lang.OutOfMemoryError" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2018-03-08T00:00:00+08:00","datePublished":"2018-03-08T00:00:00+08:00","description":"INDEX","headline":"[Java] java.lang.OutOfMemoryError","mainEntityOfPage":{"@type":"WebPage","@id":"https://outofmemory.blog/outofmemoryerror-p1.html"},"url":"https://outofmemory.blog/outofmemoryerror-p1.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="content"> <header> <div class="main"> <a href="https://outofmemory.blog/">Out of Memory</a> </div> <nav> <a class='' href="/">首页</a> <!-- <a class='' href="/archives.html"> Archives</a> --> <a class='' href="/about.html">关于</a> </nav> </header> <hr class="light-hr"> <main> <div class="title"> <h1 class="title">[Java] java.lang.OutOfMemoryError</h1> <div class="meta"> <time datetime="08-03-2018">Mar 08 2018</time> </div> </div> <hr class="no-margin light-hr "> <blockquote> <p><a href="/outofmemoryerror">INDEX</a></p> </blockquote> <h2 id="javalangoutofmemoryerror-java-heap-space">java.lang.OutOfMemoryError: Java heap space</h2> <p>Java applications are only allowed to use a limited amount of memory. This limit is specified during application startup. To make things more complex, Java memory is separated into two different regions. These regions are called Heap space and Permgen (for Permanent Generation):</p> <center> <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/assets/dist/images/90e0sol3g.pic.png" /> <br /> </center> <p>The size of those regions is set during the Java Virtual Machine (JVM) launch and can be customized by specifying JVM parameters <code class="language-plaintext highlighter-rouge">-Xmx</code> and <code class="language-plaintext highlighter-rouge">-XX:MaxPermSize</code>. If you do not explicitly set the sizes, platform-specific defaults will be used.</p> <p>The <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: Java heap space</code> error will be triggered when the application attempts to add more data into the heap space area, but there is not enough room for it.</p> <p>Note that there might be plenty of physical memory available, but the <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: Java heap space</code> error is thrown whenever the JVM reaches the heap size limit.</p> <h3 id="what-is-causing-it">What is causing it?</h3> <p>There most common reason for the <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: Java heap space</code> error is simple you try to fit an XXL application into an S-sized Java heap space. That is the application just requires more Java heap space than available to it to operate normally. Other causes for this OutOfMemoryError message are more complex and are caused by a programming error:</p> <ul> <li>Spikes in <code class="language-plaintext highlighter-rouge">usage/data</code> volume. The application was designed to handle a certain amount of users or a certain amount of data. When the number of users or the volume of data suddenly spikes and crosses that expected threshold, the operation which functioned normally before the spike ceases to operate and triggers the <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: Java heap space error</code>.</li> <li>Memory leaks. A particular type of programming error will lead your application to constantly consume more memory. Every time the leaking functionality of the application is used it leaves some objects behind into the Java heap space. Over time the leaked objects consume all of the available Java heap space and trigger the already familiar <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: Java heap space</code> error.</li> </ul> <h3 id="give-me-an-example">Give me an example</h3> <h4 id="trivial-example">Trivial example</h4> <p>The first example is truly simple the following Java code tries to allocate an array of 2M integers. When you compile it and launch with 12MB of Java heap space (<code class="language-plaintext highlighter-rouge">java -Xmx12m OOM</code>), it fails with the <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: Java heap space</code> message. With 13MB Java heap space the program runs just fine.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OOM</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">SIZE</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">i</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">SIZE</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h4 id="memory-leak-example">Memory leak example</h4> <p>The second and a more realistic example is of a memory leak. In Java, when developers create and use new objects e.g. <code class="language-plaintext highlighter-rouge">new Integer(5)</code>, they don’t have to allocate memory themselves this is being taken care of by the Java Virtual Machine (JVM). During the life of the application the JVM periodically checks which objects in memory are still being used and which are not. Unused objects can be discarded and the memory reclaimed and reused again. This process is called Garbage Collection. The corresponding module in JVM taking care of the collection is called the Garbage Collector (GC).</p> <p>Java’s automatic memory management relies on GC to periodically look for unused objects and remove them. Simplifying a bit we can say that a memory leak in Java is a situation where some objects are no longer used by the application but Garbage Collection fails to recognize it. As a result these unused objects remain in Java heap space indefinitely. This pileup will eventually trigger the <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: Java heap space</code> error.</p> <p>It is fairly easy to construct a Java program that satisfies the definition of a memory leak:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">KeylessEntry</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Key</span> <span class="o">{</span>
        <span class="nc">Integer</span> <span class="n">id</span><span class="o">;</span>

        <span class="nc">Key</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">id</span><span class="o">.</span><span class="na">hashCode</span><span class="o">();</span>
        <span class="o">}</span>
     <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
          <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">m</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="k">new</span> <span class="nc">Key</span><span class="o">(</span><span class="n">i</span><span class="o">))){</span>
                <span class="n">m</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Key</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="s">"Number:"</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
          <span class="o">}</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"m.size()="</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>When you execute the above code above you might expect it to run forever without any problems, assuming that the naive caching solution only expands the underlying Map to 10,000 elements, as beyond that all the keys will already be present in the HashMap. However, in reality the elements will keep being added as the Key class does not contain a proper <code class="language-plaintext highlighter-rouge">equals()</code> implementation next to its <code class="language-plaintext highlighter-rouge">hashCode()</code>.</p> <p>As a result, over time, with the leaking code constantly used, the “cached” results end up consuming a lot of Java heap space. And when the leaked memory fills all of the available memory in the heap region and Garbage Collection is not able to clean it, the <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError:Java heap space</code> is thrown.</p> <p>The solution would be easy add the implementation for the <code class="language-plaintext highlighter-rouge">equals()</code> method similar to the one below and you will be good to go. But before you manage to find the cause, you will definitely have lose some precious brain cells.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">response</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Key</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">response</span> <span class="o">=</span> <span class="o">(((</span><span class="nc">Key</span><span class="o">)</span><span class="n">o</span><span class="o">).</span><span class="na">id</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">response</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="what-is-the-solution">What is the solution?</h3> <p>In some cases, the amount of heap you have allocated to your JVM is just not enough to accommodate the needs of your applications running on that JVM. In that case, you should just allocate more heap see at the end of this chapter for how to achieve that.</p> <p>In many cases however, providing more Java heap space will not solve the problem. For example, if your application contains a memory leak, adding more heap will just postpone the <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: Java heap space</code> error. Additionally, increasing the amount of Java heap space also tends to increase the length of GC pauses affecting your application’s throughput or latency.</p> <p>If you wish to solve the underlying problem with the Java heap space instead of masking the symptoms, you need to figure out which part of your code is responsible for allocating the most memory. In other words, you need to answer these questions:</p> <ul> <li>Which objects occupy large portions of heap.</li> <li>where these objects are being allocated in source code.</li> </ul> <p>At this point, make sure to clear a couple of days in your calendar (or see an automated way below the bullet list). Here is a rough process outline that will help you answer the above questions:</p> <p>Get security clearance in order to perform a heap dump from your JVM. “Dumps” are basically snapshots of heap contents that you can analyze. These snapshot can thus contain confidential information, such as passwords, credit card numbers etc, so acquiring such a dump might not even be possible for security reasons.</p> <p>Get the dump at the right moment. Be prepared to get a few dumps, as when taken at a wrong time, heap dumps contain a significant amount of noise and can be practically useless. On the other hand, every heap dump “freezes” the JVM entirely, so don’t take too many of them or your end users start facing performance issues.</p> <p>Find a machine that can load the dump. When your JVM-to-troubleshoot uses for example 8GB of heap, you need a machine with more than 8GB to be able to analyze heap contents. Fire up dump analysis software (we recommend Eclipse MAT, but there are also equally good alternatives available).</p> <p>Detect the paths to GC roots of the biggest consumers of heap. We have covered this activity in a separate post here. It is especially tough for beginners, but the practice will make you understand the structure and navigation mechanics.</p> <p>Next, you need to figure out where in your source code the potentially hazardous large amount of objects is being allocated. If you have good knowledge of your application’s source code you’ll be able to do this in a couple searches.</p> <p>Alternatively, we suggest Plumbr, the only Java monitoring solution with automatic root cause detection. Among other performance problems it catches all <em>java.lang.OutOfMemoryError</em>s and automatically hands you the information about the most memory-hungry data structres.</p> <p>Plumbr takes care of gathering the necessary data behind the scenes this includes the relevant data about heap usage (only the object layout graph, no actual data), and also some data that you can’t even find in a heap dump. It also does the necessary data processing for you – on the fly, as soon as the JVM encounters an <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError</code>. Here is an example <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError</code> incident alert from Plumbr:</p> <center> <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/assets/dist/images/3kbr3c2sa.pic.png" /> <br /> </center> <p>Without any additional tooling or analysis you can see:</p> <ul> <li>Which objects are consuming the most memory (271 <code class="language-plaintext highlighter-rouge">com.example.map.impl.PartitionContainer</code> instances consume 173MB out of 248MB total heap).</li> <li>Where these objects were allocated (most of them allocated in the MetricManagerImpl class, line 304).</li> <li>What is currently referencing these objects (the full reference chain up to GC root).</li> </ul> <p>Equipped with this information you can zoom in to the underlying root cause and make sure the data structures are trimmed down to the levels where they would fit nicely into your memory pools.</p> <p>However, when your conclusion from memory analysis or from reading the Plumbr report are that memory use is legal and there is nothing to change in the source code, you need to allow your JVM more Java heap space to run properly. In this case, alter your JVM launch configuration and add (or increase the value if present) the following:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-Xmx1024m</span>
</code></pre></div></div> <p>The above configuration would give the application 1024MB of Java heap space. You can use g or G for GB, m or M for MB, k or K for KB. For example all of the following are equivalent to saying that the maximum Java heap space is 1GB:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">-Xmx1073741824</span> com.mycompany.MyClass
java <span class="nt">-Xmx1048576k</span> com.mycompany.MyClass
java <span class="nt">-Xmx1024m</span> com.mycompany.MyClass
java <span class="nt">-Xmx1g</span> com.mycompany.MyClass 
</code></pre></div></div> <div class="post-tags"> <nav class="nav-post-tags-list"> <ul class="tags"> <li><a href="/tag/java/">Java</a></li> <li><a href="/tag/oom/">OOM</a></li> <li><a href="/tag/jvm/">JVM</a></li> </ul> </nav> </div> </main> <footer> <hr class="footer-hr"> <div class="ui-flex"> <div class='wrapper-footer'> © 2025 Out of Memory.blog | <a href="mailto:yvens.fv@gmail.com">yvens</a> </div> </div> </footer> </div> </body> </html>
