<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="shortcut icon" href="/favicon.ico"> <title>[Database] Mysql 最左匹配原则 - LanKE.e 婪歌</title> <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet"> <link rel="stylesheet" href="/assets/dist/css/style.css"> <!-- <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_big-stone.min.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_white.min.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-base16.dark.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-github.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> --> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>[Database] Mysql 最左匹配原则 | LanKE.e 婪歌</title> <meta name="generator" content="Jekyll v3.9.2" /> <meta property="og:title" content="[Database] Mysql 最左匹配原则" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="最左匹配原则（leftmost perfix，也可以翻译为最左前缀），一般现在网上通俗化的解释是： 在 MySQL 建立联合索引时会遵守最左匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。" /> <meta property="og:description" content="最左匹配原则（leftmost perfix，也可以翻译为最左前缀），一般现在网上通俗化的解释是： 在 MySQL 建立联合索引时会遵守最左匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。" /> <link rel="canonical" href="https://lankee.blog/mysql-index-leftmost-prefix.html" /> <meta property="og:url" content="https://lankee.blog/mysql-index-leftmost-prefix.html" /> <meta property="og:site_name" content="LanKE.e 婪歌" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2019-07-11T00:00:00+08:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="[Database] Mysql 最左匹配原则" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2019-07-11T00:00:00+08:00","datePublished":"2019-07-11T00:00:00+08:00","description":"最左匹配原则（leftmost perfix，也可以翻译为最左前缀），一般现在网上通俗化的解释是： 在 MySQL 建立联合索引时会遵守最左匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。","headline":"[Database] Mysql 最左匹配原则","mainEntityOfPage":{"@type":"WebPage","@id":"https://lankee.blog/mysql-index-leftmost-prefix.html"},"url":"https://lankee.blog/mysql-index-leftmost-prefix.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="content"> <header> <div class="main"> <a href="https://lankee.blog/">LanKE.e 婪歌</a> </div> <nav> <a class='' href="/">首页</a> <!-- <a class='' href="/archives.html"> Archives</a> --> <a class='' href="/about.html">关于</a> </nav> </header> <hr class="light-hr"> <main> <div class="title"> <h1 class="title">[Database] Mysql 最左匹配原则</h1> <div class="meta"> <time datetime="11-07-2019">Jul 11 2019</time> </div> </div> <hr class="no-margin light-hr "> <p>最左匹配原则（leftmost perfix，也可以翻译为最左前缀），一般现在网上通俗化的解释是：</p> <blockquote> <p>在 MySQL 建立联合索引时会遵守最左匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p> </blockquote> <p>其实这个解释会让人搞不太清楚具体是什么意思，再看看官方文档是怎么描述的（在 MySQL 5.7 Reference Manual - <a href="https://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html" target="_blank">8.3.6 Multiple-Column Indexes</a> 一节中）：</p> <blockquote> <p>MySQL can use multiple-column indexes for queries that test all the columns in the index, or queries that test just the first column, the first two columns, the first three columns, and so on. If you specify the columns in the right order in the index definition, a single composite index can speed up several kinds of queries on the same table.</p> </blockquote> <p>简单翻译一下：</p> <blockquote> <p>MySQL 可以使用联合索引来处理涉及到索引中的所有列或仅涉及索引中前几列的查询。如果你按正确的顺序在索引定义中指定这些列，那么联合索引就可以加速同一张表上多种类型的查询。</p> </blockquote> <p>不论是网上一般的解释，还是官方描述其实都比较简单，但在实际查询过程中情况就比较复杂了，那么下面通过几个 SQL 查询例子试着搞清楚。</p> <h2 id="来点-">来点 🌰</h2> <p>先创建一个测试表，然后添加一点测试数据（Mysql 版本 5.7）：</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 建表</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`test_tb`</span> <span class="p">(</span>
  <span class="nv">`id`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="nv">`col1`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`col2`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="nb">CHARACTER</span> <span class="k">SET</span> <span class="n">utf8</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`col3`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="nv">`col4`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">),</span>  <span class="c1">-- 主键索引</span>
  <span class="k">KEY</span> <span class="nv">`idx1`</span> <span class="p">(</span><span class="nv">`col1`</span><span class="p">,</span><span class="nv">`col2`</span><span class="p">,</span><span class="nv">`col3`</span><span class="p">)</span>   <span class="c1">-- 联合索引</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">11</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span><span class="p">;</span>

<span class="c1">-- 测试数据</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">test_tb</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span><span class="n">col2</span><span class="p">,</span><span class="n">col3</span><span class="p">,</span><span class="n">col4</span><span class="p">)</span> <span class="n">VALUE</span><span class="p">(</span><span class="mi">101</span><span class="p">,</span><span class="nv">"102"</span><span class="p">,</span><span class="mi">103</span><span class="p">,</span><span class="mi">104</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">test_tb</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span><span class="n">col2</span><span class="p">,</span><span class="n">col3</span><span class="p">,</span><span class="n">col4</span><span class="p">)</span> <span class="n">VALUE</span><span class="p">(</span><span class="mi">202</span><span class="p">,</span><span class="nv">"202"</span><span class="p">,</span><span class="mi">203</span><span class="p">,</span><span class="mi">204</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">test_tb</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span><span class="n">col2</span><span class="p">,</span><span class="n">col3</span><span class="p">,</span><span class="n">col4</span><span class="p">)</span> <span class="n">VALUE</span><span class="p">(</span><span class="mi">301</span><span class="p">,</span><span class="nv">"302"</span><span class="p">,</span><span class="mi">303</span><span class="p">,</span><span class="mi">304</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">test_tb</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span><span class="n">col2</span><span class="p">,</span><span class="n">col3</span><span class="p">,</span><span class="n">col4</span><span class="p">)</span> <span class="n">VALUE</span><span class="p">(</span><span class="mi">401</span><span class="p">,</span><span class="nv">"402"</span><span class="p">,</span><span class="mi">403</span><span class="p">,</span><span class="mi">404</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">test_tb</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span><span class="n">col2</span><span class="p">,</span><span class="n">col3</span><span class="p">,</span><span class="n">col4</span><span class="p">)</span> <span class="n">VALUE</span><span class="p">(</span><span class="mi">501</span><span class="p">,</span><span class="nv">"502"</span><span class="p">,</span><span class="mi">503</span><span class="p">,</span><span class="mi">504</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">test_tb</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span><span class="n">col2</span><span class="p">,</span><span class="n">col3</span><span class="p">,</span><span class="n">col4</span><span class="p">)</span> <span class="n">VALUE</span><span class="p">(</span><span class="mi">601</span><span class="p">,</span><span class="nv">"602"</span><span class="p">,</span><span class="mi">603</span><span class="p">,</span><span class="mi">604</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">test_tb</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span><span class="n">col2</span><span class="p">,</span><span class="n">col3</span><span class="p">,</span><span class="n">col4</span><span class="p">)</span> <span class="n">VALUE</span><span class="p">(</span><span class="mi">701</span><span class="p">,</span><span class="nv">"702"</span><span class="p">,</span><span class="mi">703</span><span class="p">,</span><span class="mi">704</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">test_tb</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span><span class="n">col2</span><span class="p">,</span><span class="n">col3</span><span class="p">,</span><span class="n">col4</span><span class="p">)</span> <span class="n">VALUE</span><span class="p">(</span><span class="mi">801</span><span class="p">,</span><span class="nv">"802"</span><span class="p">,</span><span class="mi">803</span><span class="p">,</span><span class="mi">804</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">test_tb</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span><span class="n">col2</span><span class="p">,</span><span class="n">col3</span><span class="p">,</span><span class="n">col4</span><span class="p">)</span> <span class="n">VALUE</span><span class="p">(</span><span class="mi">901</span><span class="p">,</span><span class="nv">"902"</span><span class="p">,</span><span class="mi">903</span><span class="p">,</span><span class="mi">904</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">test_tb</span><span class="p">(</span><span class="n">col1</span><span class="p">,</span><span class="n">col2</span><span class="p">,</span><span class="n">col3</span><span class="p">,</span><span class="n">col4</span><span class="p">)</span> <span class="n">VALUE</span><span class="p">(</span><span class="mi">1001</span><span class="p">,</span><span class="nv">"1002"</span><span class="p">,</span><span class="mi">1003</span><span class="p">,</span><span class="mi">1004</span><span class="p">);</span>
</code></pre></div></div> <p>先看下面几条 SQL 的执行分析结果：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; explain select * from test_tb where col1 = 1;  --索引生效
+----+-------------+---------+------------+------+---------------+------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test_tb | NULL       | ref  | idx1          | idx1 | 5       | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; explain select * from test_tb where col1 = 1 and col2 = '2';  --索引生效
+----+-------------+---------+------------+------+---------------+------+---------+-------------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref         | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | test_tb | NULL       | ref  | idx1          | idx1 | 104     | const,const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; explain select * from test_tb where col1 = 1 and col2 = '2' and col3 = 3;  --索引生效
+----+-------------+---------+------------+------+---------------+------+---------+-------------------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref               | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+------+---------+-------------------+------+----------+-------+
|  1 | SIMPLE      | test_tb | NULL       | ref  | idx1          | idx1 | 109     | const,const,const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+------+---------+-------------------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)

mysql&gt; explain select * from test_tb where col2 = '2' and col1 = 1 and col3 = 3;  --索引生效
+----+-------------+---------+------------+------+---------------+------+---------+-------------------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref               | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+------+---------+-------------------+------+----------+-------+
|  1 | SIMPLE      | test_tb | NULL       | ref  | idx1          | idx1 | 109     | const,const,const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+------+---------+-------------------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)

mysql&gt; explain select * from test_tb where col2 = '2' and col3 = 3;  --索引不生效
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test_tb | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   10 |    10.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; explain select * from test_tb where col3 = 3 and col1 = 1;  --只有 col1 列索引生效
+----+-------------+---------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+---------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | test_tb | NULL       | ref  | idx1          | idx1 | 5       | const |    1 |    10.00 | Using index condition |
+----+-------------+---------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.01 sec)
</code></pre></div></div> <p>根据分析结果的 type 列和 ref 列（Explain 的详解可以参考官方文档 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank">8.8.2 EXPLAIN Output Format</a>）可以发现，<strong>只要查询条件中的 N 列包含于联合索引的最左连续的 N 列，联合索引就会生效。</strong>也就是说我们创建<strong>联合索引 <code class="language-plaintext highlighter-rouge">idx1(col1,col2,col3)</code>，相当于创建了 <code class="language-plaintext highlighter-rouge">(col1)、(col1,col2)、(col1,col2,col3)</code> 这三个索引。</strong> 也可以发现<strong>查询条件中列顺序不会影响索引生效</strong>，这是因为 <strong>Mysql 的查询优化器</strong>，这点顺序问题还是能解决的。</p> <p>但是下面这句 SQL 的分析结果：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; explain select col1,col2,col3 from test_tb where col2 ='2' and col3 = 3;
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+--------------------------+
| id | select_type | table   | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | test_tb | NULL       | index | NULL          | idx1 | 109     | NULL |   10 |    10.00 | Using where; Using index |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.01 sec)
</code></pre></div></div> <p>可以看到 type 不是 NULL，说明是走了索引的，但是这不符合联合索引需要最左连续列的定义，为什么呢？</p> <h3 id="覆盖索引">覆盖索引</h3> <p>我们知道在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。而 InnoDB 使用了 B+ 树（本节对 B+ 树不做详解）索引模型，所以数据都是存储在 B+ 树中的。根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p> <ul> <li>主键索引（clustered index）也就是<strong>聚簇索引</strong>，在叶子节点的是整行数据。<em><font style="color:#999">（注：聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。）</font></em></li> <li>非主键索引（secondary index）也就是<strong>二级索引</strong>，在叶子节点的内容是主键的值。</li> </ul> <p>所以使用 <code class="language-plaintext highlighter-rouge">select * from test_tb where id =1;</code> 这种主键查询方式，就只需要查询主键索引对应的那棵树。而使用 <code class="language-plaintext highlighter-rouge">select * from test_tb where col1 = 1;</code> 这样的非主键索引查询方式，就需要先查询 idx1 这个索引对应的那棵树得到 id 值之后，再到主键索引树查询，这个过程称之为<strong>回表</strong>。</p> <p>使用非主键查询需要多扫描一棵树，会降低查询效率，怎么尽量不回表呢？除了主键查询，就是<strong>覆盖索引</strong>了。根据上面的概述，如果二级索引查询的时候只查询查询索引里包含的字段，也就是索引中覆盖了你查询的字段，那就不需要回表了。这就解释了上面的示例为什么是走了索引的，因为查询的字段包含在联合索引 <code class="language-plaintext highlighter-rouge">idx1(col1,col2,col3)</code> 中，不需要回表，也就是覆盖索引。</p> <h3 id="中断匹配索引">中断匹配索引</h3> <p>之前的示例中，最后一条 SQL 条件列不连续会中断索引，还有哪些情况会中断联合索引，最常见的说法是遇到范围查询如（<code class="language-plaintext highlighter-rouge">&lt;,&gt;,between,like</code>）就会中断匹配索引。</p> <p>示例：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; explain select * from test_tb where col1 &gt; 1 and col2 = '2' and col3 = 3;
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test_tb | NULL       | ALL  | idx1          | NULL | NULL    | NULL |   10 |    10.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)
</code></pre></div></div> <p>根据测试，确实如 <code class="language-plaintext highlighter-rouge">&lt;,&gt;,between,!=,not in</code> 这样的范围查询是会中断匹配的（因为篇幅没有把所有查询示例列出，感兴趣的可以自己执行查看），虽然 in 也是范围查询，但是不会中断匹配：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; explain select * from test_tb where col1 in (1,2) and col2 = '2' and col3 = 3;  --(col1 = 1 or col1 =2)结果是一样的
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | test_tb | NULL       | range | idx1          | idx1 | 109     | NULL |    2 |   100.00 | Using index condition |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
</code></pre></div></div> <p>但是 <code class="language-plaintext highlighter-rouge">like</code> 的情况有些复杂：<br /> * 注：<code class="language-plaintext highlighter-rouge">like</code> 默认是左匹配查询，也就是 <code class="language-plaintext highlighter-rouge">like 'x'</code> 等价于 <code class="language-plaintext highlighter-rouge">like 'x%'</code>。<code class="language-plaintext highlighter-rouge">rlike</code> 就是右匹配查询。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; explain select * from test_tb where col1 = 1 and col2 like '1' and col3 = 3;  
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | test_tb | NULL       | range | idx1          | idx1 | 109     | NULL |    1 |   100.00 | Using index condition |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.01 sec)

mysql&gt; explain select * from test_tb where col1 = 1 and col2 like '%1' and col3 = 3;  -- like '%1%' 执行分析结果相同
+----+-------------+---------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+---------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | test_tb | NULL       | ref  | idx1          | idx1 | 5       | const |    1 |    10.00 | Using index condition |
+----+-------------+---------+------------+------+---------------+------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.01 sec)
</code></pre></div></div> <p>可以发现，使用左匹配 <code class="language-plaintext highlighter-rouge">like '1'</code> 不会中断匹配索引。<code class="language-plaintext highlighter-rouge">like '%1'</code> 和 <code class="language-plaintext highlighter-rouge">like '%1%'</code> 才会中断匹配。</p> <p>也就是说<strong>最左匹配原则不光指联合索引中的列，也是字符串索引中的字符。</strong></p> <p>其他情况：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; explain select * from test_tb where col1 = 1 or col2 = '2' and col3 = 3;   -- 列间使用 or
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test_tb | NULL       | ALL  | idx1          | NULL | NULL    | NULL |   10 |    10.90 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; explain select * from test_tb where col1 - 1 = 1 and col2 = '2' and col3 = 3;  -- 列参与计算
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test_tb | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   10 |    10.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; explain select * from test_tb where date(col1) = 1 and col2 = '2' and col3 = 3;  -- 列包含在函数式里
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test_tb | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   10 |    10.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)
</code></pre></div></div> <div class="post-tags"> <nav class="nav-post-tags-list"> <ul class="tags"> <li><a href="/tag/database/">Database</a></li> <li><a href="/tag/mysql/">Mysql</a></li> <li><a href="/tag/index/">Index</a></li> </ul> </nav> </div> </main> <footer> <hr class="footer-hr"> <div class="ui-flex"> <div class='wrapper-footer'> © 2023 LanKE.e 婪歌 | <a href="mailto:dr.xx.yvens@gmail.com">Yven Fong</a> </div> </div> </footer> </div> </body> </html>
