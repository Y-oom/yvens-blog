<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="shortcut icon" href="/favicon.ico"> <title>[DATABASE] MySQL 关于 count() 不同用法的效率问题 - Out of Memory</title> <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet"> <link rel="stylesheet" href="/assets/dist/css/style.css"> <!-- <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_big-stone.min.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_white.min.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-base16.dark.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-github.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> --> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>[DATABASE] MySQL 关于 count() 不同用法的效率问题 | Out of Memory</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="[DATABASE] MySQL 关于 count() 不同用法的效率问题" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="* 本文基于 MySQL 5.7 + InnoDB 引擎" /> <meta property="og:description" content="* 本文基于 MySQL 5.7 + InnoDB 引擎" /> <link rel="canonical" href="https://outofmemory.blog/mysql-count-about.html" /> <meta property="og:url" content="https://outofmemory.blog/mysql-count-about.html" /> <meta property="og:site_name" content="Out of Memory" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2019-07-14T00:00:00+08:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="[DATABASE] MySQL 关于 count() 不同用法的效率问题" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2019-07-14T00:00:00+08:00","datePublished":"2019-07-14T00:00:00+08:00","description":"* 本文基于 MySQL 5.7 + InnoDB 引擎","headline":"[DATABASE] MySQL 关于 count() 不同用法的效率问题","mainEntityOfPage":{"@type":"WebPage","@id":"https://outofmemory.blog/mysql-count-about.html"},"url":"https://outofmemory.blog/mysql-count-about.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="content"> <header> <div class="main"> <a href="https://outofmemory.blog/">Out of Memory</a> </div> <nav> <a class='' href="/">首页</a> <!-- <a class='' href="/archives.html"> Archives</a> --> <a class='' href="/about.html">关于</a> </nav> </header> <hr class="light-hr"> <main> <div class="title"> <h1 class="title">[DATABASE] MySQL 关于 count() 不同用法的效率问题</h1> <div class="meta"> <time datetime="14-07-2019">Jul 14 2019</time> </div> </div> <hr class="no-margin light-hr "> <p>* <em>本文基于 MySQL 5.7 + InnoDB 引擎</em></p> <hr /> <h2 id="count1-vs-countid-vs-countcolmun-vs-count--who-is-faster">count(1) vs count(id) vs count(colmun) vs count(*) : Who is faster?</h2> <p>对于这几种查询写法的效率问题，经常会被面试官问到。</p> <p>先说<strong>结论：<code class="language-plaintext highlighter-rouge">count(*) = count(1) &gt; count(id) &gt; count(colmun)</code></strong></p> <h2 id="解析">解析</h2> <p><code class="language-plaintext highlighter-rouge">count()</code> 是一个聚合函数，对于返回的结果集，server 层会维护一个变量 count，然后一行行地循环判断，如果 <code class="language-plaintext highlighter-rouge">count()</code> 的参数不是 <code class="language-plaintext highlighter-rouge">NULL</code>，count 就加 1，否则不加。最后返回 count 给客户端。</p> <p>而 InnoDB 在循环的时候，是循环的索引。在官方文档（MySQL 5.7 Reference Manual - <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_count" target="_blank">12.20.1 Aggregate Function Descriptions</a>）中 <code class="language-plaintext highlighter-rouge">count()</code> 函数说明有这么一段：</p> <blockquote> <p>Prior to MySQL 5.7.18, InnoDB processes <code class="language-plaintext highlighter-rouge">SELECT COUNT(*)</code> statements by scanning the clustered index. As of MySQL 5.7.18, InnoDB processes <code class="language-plaintext highlighter-rouge">SELECT COUNT(*)</code> statements by traversing the smallest available secondary index unless an index or optimizer hint directs the optimizer to use a different index. If a secondary index is not present, the clustered index is scanned.<br /> <br /> 在 MySQL 5.7.18 之前，InnoDB 通过扫描聚簇索引来处理 <code class="language-plaintext highlighter-rouge">SELECT COUNT(*)</code> 语句。从 MySQL 5.7.18 开始，除非有一个索引或优化器提示指示优化器使用一个不同的索引，否则 InnoDB 会通过遍历可用的最小二级索引来处理 <code class="language-plaintext highlighter-rouge">SELECT COUNT(*)</code> 语句。如果不存在二级索引，则扫描聚簇索引。</p> </blockquote> <p>虽然文档是写的 <code class="language-plaintext highlighter-rouge">SELECT COUNT(*)</code>，事实上，不光是 <code class="language-plaintext highlighter-rouge">count(*)</code>，<code class="language-plaintext highlighter-rouge">count(1)</code> 和 <code class="language-plaintext highlighter-rouge">count(colmun)</code> (colmun 为任何<strong>索引列</strong>，包括主键索引) 也都是一样的。</p> <p><strong>没有二级索引：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; explain select count(id) from test_tb1;
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test_tb1 | NULL       | index | NULL          | PRIMARY | 4       | NULL |    1 |   100.00 | Using index |
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; explain select count(1) from test_tb1;
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test_tb1 | NULL       | index | NULL          | PRIMARY | 4       | NULL |    1 |   100.00 | Using index |
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">key</code> 列为 <code class="language-plaintext highlighter-rouge">PRIMARY</code>，走聚簇索引。</p> <p><strong>有二级索引：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; explain select count(id) from test_tb;
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test_tb | NULL       | index | NULL          | idx1 | 109     | NULL |   10 |   100.00 | Using index |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)

mysql&gt; explain select count(1) from test_tb;
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test_tb | NULL       | index | NULL          | idx1 | 109     | NULL |   10 |   100.00 | Using index |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; explain select count(col1) from test_tb;
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test_tb | NULL       | index | NULL          | idx1 | 109     | NULL |   10 |   100.00 | Using index |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">key</code> 列为 <code class="language-plaintext highlighter-rouge">idx1</code>，走二级索引 <code class="language-plaintext highlighter-rouge">idx1</code>。</p> <p>为什么选择的是二级索引而不是聚簇索引呢？应该是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小。</p> <h3 id="countcolmun">count(colmun)</h3> <p>先从最慢的说起，<code class="language-plaintext highlighter-rouge">count(colmun)</code> 有以下几种情况：</p> <ol> <li>如果”colmun”定义为 <code class="language-plaintext highlighter-rouge">not null</code> 的话，一行行地从记录里面读出这个字段，判断不能为 <code class="language-plaintext highlighter-rouge">null</code>，按行累加。</li> <li>如果”colmun”定义允许为 <code class="language-plaintext highlighter-rouge">null</code>，那么执行的时候，判断到有可能是 <code class="language-plaintext highlighter-rouge">null</code>，还要把值取出来再判断一下，不是 <code class="language-plaintext highlighter-rouge">null</code> 才累加。</li> <li>如果”colmun”不是索引列的话，还要执行全表扫描。 <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; explain select count(col1) from test_tb;
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | test_tb | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   10 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)
</code></pre></div> </div> </li> </ol> <h3 id="countid">count(id)</h3> <p>遍历表索引（二级索引，没有就是聚簇索引），把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p> <h3 id="count1">count(1)</h3> <p>遍历表索引（二级索引，没有就是聚簇索引），但<strong>不取值</strong>。server 层对于返回的每一行，参数“1”很明显不可能为空的，按行累加。</p> <p>可以看到 <code class="language-plaintext highlighter-rouge">count(1)</code> 比 <code class="language-plaintext highlighter-rouge">count(id)</code> 少了一步取值，所以通常来说 <code class="language-plaintext highlighter-rouge">count(1)</code> 的执行效率会比 <code class="language-plaintext highlighter-rouge">count(id)</code> 稍微高一点。</p> <h3 id="count">count(*)</h3> <p>还是这篇官方文档（MySQL 5.7 Reference Manual - <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_count" target="_blank">12.20.1 Aggregate Function Descriptions</a>），这段写的很清楚：</p> <blockquote> <p>InnoDB handles <code class="language-plaintext highlighter-rouge">SELECT COUNT(*)</code> and <code class="language-plaintext highlighter-rouge">SELECT COUNT(1)</code> operations in the same way. There is no performance difference.</p> </blockquote> <p>从执行过程建议也可以看出来：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; explain select count(*) from test_tb; show warnings;
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test_tb | NULL       | index | NULL          | idx1 | 109     | NULL |   10 |   100.00 | Using index |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

+-------+------+-----------------------------------------------------------------------+
| Level | Code | Message                                                               |
+-------+------+-----------------------------------------------------------------------+
| Note  | 1003 | /* select#1 */ select count(0) AS `count(*)` from `test_db`.`test_tb` |
+-------+------+-----------------------------------------------------------------------+
1 row in set (0.01 sec)
</code></pre></div></div> <p>执行 <code class="language-plaintext highlighter-rouge">SELECT COUNT(*)</code> 其实就是执行 <code class="language-plaintext highlighter-rouge">SELECT COUNT(0)</code>，执行逻辑和 <code class="language-plaintext highlighter-rouge">SELECT COUNT(1)</code> 相同，所以 <code class="language-plaintext highlighter-rouge">count(*)</code> = <code class="language-plaintext highlighter-rouge">count(1)</code>。</p> <p><br /></p> <div class="post-tags"> <nav class="nav-post-tags-list"> <ul class="tags"> <li><a href="/tag/database/">Database</a></li> <li><a href="/tag/mysql/">MySQL</a></li> </ul> </nav> </div> </main> <footer> <hr class="footer-hr"> <div class="ui-flex"> <div class='wrapper-footer'> © 2025 Out of Memory.blog | <a href="mailto:yvens.fv@gmail.com">yvens</a> </div> </div> </footer> </div> </body> </html>
