<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="shortcut icon" href="/favicon.ico"> <title>[Java] java.lang.OutOfMemoryError - Out of Memory</title> <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet"> <link rel="stylesheet" href="/assets/dist/css/style.css"> <!-- <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_big-stone.min.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_white.min.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-base16.dark.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-github.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> --> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>[Java] java.lang.OutOfMemoryError | Out of Memory</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="[Java] java.lang.OutOfMemoryError" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="INDEX" /> <meta property="og:description" content="INDEX" /> <link rel="canonical" href="https://outofmemory.blog/outofmemoryerror-p2.html" /> <meta property="og:url" content="https://outofmemory.blog/outofmemoryerror-p2.html" /> <meta property="og:site_name" content="Out of Memory" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2018-03-08T00:00:00+08:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="[Java] java.lang.OutOfMemoryError" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2018-03-08T00:00:00+08:00","datePublished":"2018-03-08T00:00:00+08:00","description":"INDEX","headline":"[Java] java.lang.OutOfMemoryError","mainEntityOfPage":{"@type":"WebPage","@id":"https://outofmemory.blog/outofmemoryerror-p2.html"},"url":"https://outofmemory.blog/outofmemoryerror-p2.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="content"> <header> <div class="main"> <a href="https://outofmemory.blog/">Out of Memory</a> </div> <nav> <a class='' href="/">首页</a> <!-- <a class='' href="/archives.html"> Archives</a> --> <a class='' href="/about.html">关于</a> </nav> </header> <hr class="light-hr"> <main> <div class="title"> <h1 class="title">[Java] java.lang.OutOfMemoryError</h1> <div class="meta"> <time datetime="08-03-2018">Mar 08 2018</time> </div> </div> <hr class="no-margin light-hr "> <blockquote> <p><a href="/outofmemoryerror">INDEX</a></p> </blockquote> <h2 id="javalangoutofmemoryerror-gc-overhead-limit-exceeded">java.lang.OutOfMemoryError: GC overhead limit exceeded</h2> <p>Java runtime environment contains a built-in Garbage Collection (GC) process. In many other programming languages, the developers need to manually allocate and free memory regions so that the freed memory can be reused.</p> <p>Java applications on the other hand only need to allocate memory. Whenever a particular space in memory is no longer used, a separate process called Garbage Collection clears the memory for them. How the GC detects that a particular part of memory is explained in more detail in the Garbage Collection Handbook, but you can trust the GC to do its job well.</p> <p>The <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: GC overhead limit exceeded</code> error is displayed when your application has exhausted pretty much all the available memory and GC has repeatedly failed to clean it.</p> <h3 id="what-is-causing-it">What is causing it?</h3> <p>The <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: GC overhead limit exceeded</code> error is the JVM’s way of signalling that your application spends too much time doing garbage collection with too little result. By default the JVM is configured to throw this error if it spends more than 98% of the total time doing GC and when after the GC only less than 2% of the heap is recovered.</p> <center> <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/assets/dist/images/ed9cuo79z.pic.png" /> <br /> </center> <p>What would happen if this GC overhead limit would not exist? Note that the <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: GC overhead limit exceeded</code> error is only thrown when 2% of the memory is freed after several GC cycles. This means that the small amount of heap the GC is able to clean will likely be quickly filled again, forcing the GC to restart the cleaning process again. This forms a vicious cycle where the CPU is 100% busy with GC and no actual work can be done. End users of the application face extreme slowdowns – operations which normally complete in milliseconds take minutes to finish.</p> <p>So the “<code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: GC overhead limit exceeded</code>” message is a pretty nice example of a <a href="http://en.wikipedia.org/wiki/Fail-fast" target="_blank">fail fast</a> principle in action.</p> <h3 id="give-me-an-example">Give me an example</h3> <p>In the following example we create a “<code class="language-plaintext highlighter-rouge">GC overhead limit exceeded</code>” error by initializing a Map and adding key-value pairs into the map in an unterminated loop:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.cncounter.rtime</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestWrapper</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Map</span> <span class="n">map</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">getProperties</span><span class="o">();</span>
        <span class="nc">Random</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(),</span> <span class="s">"value"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exception <span class="k">in </span>thread <span class="s2">"main"</span> java.lang.OutOfMemoryError: GC overhead limit exceeded
	at java.util.Hashtable.addEntry<span class="o">(</span>Hashtable.java:435<span class="o">)</span>
	at java.util.Hashtable.put<span class="o">(</span>Hashtable.java:476<span class="o">)</span>
	at com.cncounter.rtime.TestWrapper.main<span class="o">(</span>TestWrapper.java:11<span class="o">)</span>
</code></pre></div></div> <p>As you might guess this cannot end well. And, indeed, when we launch the above program with:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">-Xmx12m</span> <span class="nt">-XX</span>:+UseParallelGC TestWrapper
</code></pre></div></div> <p>we soon face the <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: GC overhead limit exceeded</code> message. But the above example is tricky. When launched with different Java heap size or a different GC algorithm, my Mac OS X 10.9.2 with Hotspot 1.7.0_45 will choose to die differently. For example, when I run the program with smaller Java heap size like this:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">-Xmx10m</span> <span class="nt">-XX</span>:+UseParallelGC TestWrapper
</code></pre></div></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exception <span class="k">in </span>thread <span class="s2">"main"</span> java.lang.OutOfMemoryError: Java heap space
	at java.util.Hashtable.rehash<span class="o">(</span>Hashtable.java:401<span class="o">)</span>
	at java.util.Hashtable.addEntry<span class="o">(</span>Hashtable.java:425<span class="o">)</span>
	at java.util.Hashtable.put<span class="o">(</span>Hashtable.java:476<span class="o">)</span>
	at com.cncounter.rtime.TestWrapper.main<span class="o">(</span>TestWrapper.java:11<span class="o">)</span>
</code></pre></div></div> <p>the application will die with a more common <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: Java heap space</code> message that is thrown on Map resize. And when I run it with other garbage collection algorithms besides ParallelGC, such as <code class="language-plaintext highlighter-rouge">-XX:+UseConcMarkSweepGC</code> or <code class="language-plaintext highlighter-rouge">-XX:+UseG1GC</code>, the error is caught by the default exception handler and is without stacktrace as the heap is exhausted to the extent where the stacktrace cannot even be filled on Exception creation.</p> <p>These variations are truly good examples that demonstrate that in resource-constrained situations you cannot predict the way your application is going to die so do not base your expectations on a specific sequence of actions to be completed.</p> <h3 id="what-is-the-solution">What is the solution?</h3> <p>As a tongue-in-cheek solution, if you just wished to get rid of the “<code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: GC overhead limit exceeded</code>” message, adding the following to your startup scripts would achieve just that:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-XX</span>:-UseGCOverheadLimit
</code></pre></div></div> <p>I would strongly suggest NOT to use this option though instead of fixing the problem you just postpone the inevitable: the application running out of memory and needing to be fixed. Specifying this option will just mask the original java.lang.OutOfMemoryError: GC overhead limit exceeded error with a more familiar message <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: Java heap space</code>.</p> <p>On a more serious note sometimes the GC overhead limit error is triggered because the amount of heap you have allocated to your JVM is just not enough to accommodate the needs of your applications running on that JVM. In that case, you should just allocate more heap see at the end of this chapter for how to achieve that.</p> <p>In many cases however, providing more Java heap space will not solve the problem. For example, if your application contains a memory leak, adding more heap will just postpone the <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError: Java heap space</code> error. Additionally, increasing the amount of Java heap space also tends to increase the length of GC pauses affecting your application’s throughput or latency.</p> <p>If you wish to solve the underlying problem with the Java heap space instead of masking the symptoms, you need to figure out which part of your code is responsible for allocating the most memory. In other words, you need to answer these questions:</p> <ul> <li>Which objects occupy large portions of heap.</li> <li>where these objects are being allocated in source code.</li> </ul> <p>At this point, make sure to clear a couple of days in your calendar (or see an automated way below the bullet list). Here is a rough process outline that will help you answer the above questions:</p> <ul> <li>Get clearance for acquiring a heap dump from your JVM-to-troubleshoot. “Dumps” are basically snapshots of heap contents that you can analyze, and contain everything that the application kept in memory at the time of the dump. Including passwords, credit card numbers etc.</li> <li>Instruct your JVM to dump the contents of its heap memory into a file. Be prepared to get a few dumps, as when taken at a wrong time, heap dumps contain a significant amount of noise and can be practically useless. On the other hand, every heap dump “freezes” the JVM entirely, so don’t take too many of them or your end users start swearing.</li> <li>Find a machine that can load the dump. When your JVM-to-troubleshoot uses for example 8GB of heap, you need a machine with more than 8GB to be able to analyze heap contents. Fire up dump analysis software (we recommend <a href="http://www.eclipse.org/mat/" target="_blank">Eclipse MAT</a>, but there are also equally good alternatives available).</li> <li>Detect the paths to GC roots of the biggest consumers of heap. We have covered this activity in a separate post <a href="https://plumbr.eu/blog/memory-leaks/solving-outofmemoryerror-dump-is-not-a-waste" target="_blank">here</a>. Don’t worry, it will feel cumbersome at first, but you’ll get better after spending a few days digging.</li> <li>Next, you need to figure out where in your source code the potentially hazardous large amount of objects is being allocated. If you have good knowledge of your application’s source code you’ll hopefully be able to do this in a couple searches. When you have less luck, you will need some energy drinks to assist.</li> </ul> <p>Alternatively, we suggest Plumbr, the only Java monitoring solution with automatic root cause detection. Among other performance problems it catches all <em>java.lang.OutOfMemoryError</em>s and automatically hands you the information about the most memory-hungry data structres. It takes care of gathering the necessary data behind the scenes this includes the relevant data about heap usage (only the object layout graph, no actual data), and also some data that you can’t even find in a heap dump. It also does the necessary data processing for you on the fly, as soon as the JVM encounters an <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError</code>. Here is an example <code class="language-plaintext highlighter-rouge">java.lang.OutOfMemoryError</code> incident alert from Plumbr:</p> <center> <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/assets/dist/images/3kbr3c2sa.pic.png" /> <br /> </center> <p>Without any additional tooling or analysis you can see:</p> <ul> <li>Which objects are consuming the most memory (271 <code class="language-plaintext highlighter-rouge">com.example.map.impl.PartitionContainer</code> instances consume 173MB out of 248MB total heap).</li> <li>Where these objects were allocated (most of them allocated in the MetricManagerImpl class, line 304).</li> <li>What is currently referencing these objects (the full reference chain up to GC root).</li> </ul> <p>Equipped with this information you can zoom in to the underlying root cause and make sure the data structures are trimmed down to the levels where they would fit nicely into your memory pools.</p> <p>However, when your conclusion from memory analysis or from reading the Plumbr report are that memory use is legal and there is nothing to change in the source code, you need to allow your JVM more Java heap space to run properly. In this case, alter your JVM launch configuration and add (or increase the value if present) just one parameter in your startup scripts:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">-Xmx1024m</span> com.yourcompany.YourClass
</code></pre></div></div> <p>In the above example the Java process is given 1GB of heap. Modify the value as best fits to your JVM. However, if the result is that your JVM still dies with OutOfMemoryError, you might still not be able to avoid the manual or Plumbr-assisted analysis described above.</p> <div class="post-tags"> <nav class="nav-post-tags-list"> <ul class="tags"> <li><a href="/tag/java/">Java</a></li> <li><a href="/tag/oom/">OOM</a></li> <li><a href="/tag/jvm/">JVM</a></li> </ul> </nav> </div> </main> <footer> <hr class="footer-hr"> <div class="ui-flex"> <div class='wrapper-footer'> © 2025 Out of Memory.blog | <a href="mailto:yvens.fv@gmail.com">yvens</a> </div> </div> </footer> </div> </body> </html>
